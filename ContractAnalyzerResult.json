{
  "Unchecked transfer": {
    "numberOfDuplicates": 0,
    "findType": "function",
    "title": "XTwitter.claimStuckTokens(address) (contracts/TestContract.sol#757-765) ignores return value by ERC20token.transfer(msg.sender,balance) (contracts/TestContract.sol#764)\n",
    "check": "unchecked-transfer",
    "impact": "High",
    "confidence": "Medium",
    "sourceTest": "function claimStuckTokens(address token) external onlyOwner {\r\n        if (token == address(0x0)) {\r\n            payable(msg.sender).transfer(address(this).balance);\r\n            return;\r\n        }\r\n        IERC20 ERC20token = IERC20(token);\r\n        uint256 balance = ERC20token.balanceOf(address(this));\r\n        ERC20token.transfer(msg.sender, balance);\r\n    }",
    "lines": [
      757,
      758,
      759,
      760,
      761,
      762,
      763,
      764,
      765
    ],
    "name": "Unchecked transfer",
    "exploit": "contract Token {\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n}\ncontract MyBank{  \n    mapping(address => uint) balances;\n    Token token;\n    function deposit(uint amount) public{\n        token.transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    }\n}\n",
    "description": "The return value of an external transfer/transferFrom call is not checked",
    "recommendation": "Use `SafeERC20`, or ensure that the transfer/transferFrom return value is checked.",
    "explanation": "\nSeveral tokens do not revert in case of failure and return false. If one of these tokens is used in `MyBank`, `deposit` will not revert if the transfer fails, and an attacker can call `deposit` for free.."
  },
  "Reentrancy vulnerabilities": {
    "numberOfDuplicates": 1,
    "findType": "function",
    "title": "Reentrancy in XTwitter._transfer(address,address,uint256) (contracts/TestContract.sol#804-867):\n\tExternal calls:\n\t- uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(contractTokenBalance,0,path,address(marketingWallet),block.timestamp) (contracts/TestContract.sol#835-842)\n\tState variables written after the call(s):\n\t- super._transfer(from,address(this),fees) (contracts/TestContract.sol#863)\n\t\t- _balances[sender] = _balances[sender].sub(amount,ERC20: transfer amount exceeds balance) (contracts/TestContract.sol#652-655)\n\t\t- _balances[recipient] = _balances[recipient].add(amount) (contracts/TestContract.sol#656)\n\tERC20._balances (contracts/TestContract.sol#543) can be used in cross function reentrancies:\n\t- ERC20._mint(address,uint256) (contracts/TestContract.sol#660-666)\n\t- ERC20._transfer(address,address,uint256) (contracts/TestContract.sol#644-658)\n\t- ERC20.balanceOf(address) (contracts/TestContract.sol#571-575)\n\t- super._transfer(from,to,amount) (contracts/TestContract.sol#866)\n\t\t- _balances[sender] = _balances[sender].sub(amount,ERC20: transfer amount exceeds balance) (contracts/TestContract.sol#652-655)\n\t\t- _balances[recipient] = _balances[recipient].add(amount) (contracts/TestContract.sol#656)\n\tERC20._balances (contracts/TestContract.sol#543) can be used in cross function reentrancies:\n\t- ERC20._mint(address,uint256) (contracts/TestContract.sol#660-666)\n\t- ERC20._transfer(address,address,uint256) (contracts/TestContract.sol#644-658)\n\t- ERC20.balanceOf(address) (contracts/TestContract.sol#571-575)\n\t- swapping = false (contracts/TestContract.sol#845)\n\tXTwitter.swapping (contracts/TestContract.sol#710) can be used in cross function reentrancies:\n\t- XTwitter._transfer(address,address,uint256) (contracts/TestContract.sol#804-867)\n\nReentrancy in XTwitter._transfer(address,address,uint256) (contracts/TestContract.sol#804-867):\n\tExternal calls:\n\t- uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(contractTokenBalance,0,path,address(marketingWallet),block.timestamp) (contracts/TestContract.sol#835-842)\n\tEvent emitted after the call(s):\n\t- Transfer(sender,recipient,amount) (contracts/TestContract.sol#657)\n\t\t- super._transfer(from,address(this),fees) (contracts/TestContract.sol#863)\n\t- Transfer(sender,recipient,amount) (contracts/TestContract.sol#657)\n\t\t- super._transfer(from,to,amount) (contracts/TestContract.sol#866)\n",
    "check": "reentrancy-no-eth",
    "impact": "Medium",
    "confidence": "Medium",
    "sourceTest": "function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(\r\n            tradingEnabled ||\r\n                _isExcludedFromFees[from] ||\r\n                _isExcludedFromFees[to],\r\n            \"ERC20: trading is disabled\"\r\n        );\r\n\r\n        if (amount == 0) {\r\n            super._transfer(from, to, 0);\r\n            return;\r\n        }\r\n\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n\r\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\r\n\r\n        if (canSwap && !swapping && to == uniswapV2Pair) {\r\n            swapping = true;\r\n\r\n            if (contractTokenBalance > 0) {\r\n                address[] memory path = new address[](2);\r\n                path[0] = address(this);\r\n                path[1] = uniswapV2Router.WETH();\r\n\r\n                uniswapV2Router\r\n                    .swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                        contractTokenBalance,\r\n                        0,\r\n                        path,\r\n                        address(marketingWallet),\r\n                        block.timestamp\r\n                    );\r\n            }\r\n\r\n            swapping = false;\r\n        }\r\n\r\n        uint256 _totalFees;\r\n        if (\r\n            ((_isExcludedFromFees[from] || _isExcludedFromFees[to]) ||\r\n                (from != uniswapV2Pair && to != uniswapV2Pair)) || swapping\r\n        ) {\r\n            _totalFees = 0;\r\n        } else if (from == uniswapV2Pair) {\r\n            _totalFees = block.number <= antiBotBlockEnd ? 25 : 0;\r\n        } else {\r\n            _totalFees = block.number <= antiBotBlockEnd ? 25 : 4;\r\n        }\r\n\r\n        if (_totalFees > 0) {\r\n            uint256 fees = (amount * _totalFees) / 100;\r\n            amount = amount - fees;\r\n            super._transfer(from, address(this), fees);\r\n        }\r\n\r\n        super._transfer(from, to, amount);\r\n    }\nfunction _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(\r\n            tradingEnabled ||\r\n                _isExcludedFromFees[from] ||\r\n                _isExcludedFromFees[to],\r\n            \"ERC20: trading is disabled\"\r\n        );\r\n\r\n        if (amount == 0) {\r\n            super._transfer(from, to, 0);\r\n            return;\r\n        }\r\n\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n\r\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\r\n\r\n        if (canSwap && !swapping && to == uniswapV2Pair) {\r\n            swapping = true;\r\n\r\n            if (contractTokenBalance > 0) {\r\n                address[] memory path = new address[](2);\r\n                path[0] = address(this);\r\n                path[1] = uniswapV2Router.WETH();\r\n\r\n                uniswapV2Router\r\n                    .swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                        contractTokenBalance,\r\n                        0,\r\n                        path,\r\n                        address(marketingWallet),\r\n                        block.timestamp\r\n                    );\r\n            }\r\n\r\n            swapping = false;\r\n        }\r\n\r\n        uint256 _totalFees;\r\n        if (\r\n            ((_isExcludedFromFees[from] || _isExcludedFromFees[to]) ||\r\n                (from != uniswapV2Pair && to != uniswapV2Pair)) || swapping\r\n        ) {\r\n            _totalFees = 0;\r\n        } else if (from == uniswapV2Pair) {\r\n            _totalFees = block.number <= antiBotBlockEnd ? 25 : 0;\r\n        } else {\r\n            _totalFees = block.number <= antiBotBlockEnd ? 25 : 4;\r\n        }\r\n\r\n        if (_totalFees > 0) {\r\n            uint256 fees = (amount * _totalFees) / 100;\r\n            amount = amount - fees;\r\n            super._transfer(from, address(this), fees);\r\n        }\r\n\r\n        super._transfer(from, to, amount);\r\n    }",
    "lines": [
      804,
      805,
      806,
      807,
      808,
      809,
      810,
      811,
      812,
      813,
      814,
      815,
      816,
      817,
      818,
      819,
      820,
      821,
      822,
      823,
      824,
      825,
      826,
      827,
      828,
      829,
      830,
      831,
      832,
      833,
      834,
      835,
      836,
      837,
      838,
      839,
      840,
      841,
      842,
      843,
      844,
      845,
      846,
      847,
      848,
      849,
      850,
      851,
      852,
      853,
      854,
      855,
      856,
      857,
      858,
      859,
      860,
      861,
      862,
      863,
      864,
      865,
      866,
      867,
      804,
      805,
      806,
      807,
      808,
      809,
      810,
      811,
      812,
      813,
      814,
      815,
      816,
      817,
      818,
      819,
      820,
      821,
      822,
      823,
      824,
      825,
      826,
      827,
      828,
      829,
      830,
      831,
      832,
      833,
      834,
      835,
      836,
      837,
      838,
      839,
      840,
      841,
      842,
      843,
      844,
      845,
      846,
      847,
      848,
      849,
      850,
      851,
      852,
      853,
      854,
      855,
      856,
      857,
      858,
      859,
      860,
      861,
      862,
      863,
      864,
      865,
      866,
      867
    ],
    "name": "Reentrancy vulnerabilities",
    "exploit": "    function bug(){\n        require(not_called);\n        if( ! (msg.sender.call() ) ){\n            throw;\n        }\n        not_called = False;\n    }   \n",
    "description": "Detection of the [reentrancy bug](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy).\nDo not report reentrancies that involve Ether (see `reentrancy-eth`).",
    "recommendation": "Apply the [`check-effects-interactions` pattern](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy).",
    "explanation": ""
  },
  "Uninitialized local variables": {
    "numberOfDuplicates": 0,
    "findType": "variable",
    "title": "XTwitter.constructor().router (contracts/TestContract.sol#729) is a local variable never initialized\n",
    "check": "uninitialized-local",
    "impact": "Medium",
    "confidence": "Medium",
    "sourceTest": "address router;",
    "lines": [
      729
    ],
    "name": "Uninitialized local variables",
    "exploit": "contract Uninitialized is Owner{\n    function withdraw() payable public onlyOwner{\n        address to;\n        to.transfer(this.balance)\n    }\n}\n",
    "description": "Uninitialized local variables.",
    "recommendation": "Initialize all the variables. If a variable is meant to be initialized to zero, explicitly set it to zero to improve code readability.",
    "explanation": "\nBob calls `transfer`. As a result, all Ether is sent to the address `0x0` and is lost."
  },
  "Dead-code": {
    "numberOfDuplicates": 14,
    "findType": "function",
    "title": "SafeMath.mul(uint256,uint256) (contracts/TestContract.sol#85-94) is never used and should be removed\n\nSafeMathInt.div(int256,int256) (contracts/TestContract.sol#139-145) is never used and should be removed\n\nSafeMath.sub(uint256,uint256) (contracts/TestContract.sol#70-72) is never used and should be removed\n\nSafeMathInt.abs(int256) (contracts/TestContract.sol#159-162) is never used and should be removed\n\nSafeMathUint.toInt256Safe(uint256) (contracts/TestContract.sol#171-175) is never used and should be removed\n\nSafeMathInt.mul(int256,int256) (contracts/TestContract.sol#130-137) is never used and should be removed\n\nERC20._burn(address,uint256) (contracts/TestContract.sol#668-677) is never used and should be removed\n\nSafeMath.mod(uint256,uint256,string) (contracts/TestContract.sol#116-123) is never used and should be removed\n\nSafeMathInt.toUint256Safe(int256) (contracts/TestContract.sol#164-167) is never used and should be removed\n\nSafeMathInt.sub(int256,int256) (contracts/TestContract.sol#147-151) is never used and should be removed\n\nSafeMath.div(uint256,uint256,string) (contracts/TestContract.sol#100-110) is never used and should be removed\n\nContext._msgData() (contracts/TestContract.sol#17-19) is never used and should be removed\n\nSafeMath.mod(uint256,uint256) (contracts/TestContract.sol#112-114) is never used and should be removed\n\nSafeMathInt.add(int256,int256) (contracts/TestContract.sol#153-157) is never used and should be removed\n\nSafeMath.div(uint256,uint256) (contracts/TestContract.sol#96-98) is never used and should be removed\n",
    "check": "dead-code",
    "impact": "Informational",
    "confidence": "Medium",
    "sourceTest": "function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\nfunction div(int256 a, int256 b) internal pure returns (int256) {\r\n        // Prevent overflow when dividing MIN_INT256 by -1\r\n        require(b != -1 || a != MIN_INT256);\r\n\r\n        // Solidity already throws when dividing by 0.\r\n        return a / b;\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\nfunction abs(int256 a) internal pure returns (int256) {\r\n        require(a != MIN_INT256);\r\n        return a < 0 ? -a : a;\r\n    }\nfunction toInt256Safe(uint256 a) internal pure returns (int256) {\r\n        int256 b = int256(a);\r\n        require(b >= 0);\r\n        return b;\r\n    }\nfunction mul(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a * b;\r\n\r\n        // Detect overflow when multiplying MIN_INT256 with -1\r\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\nfunction _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n        _balances[account] = _balances[account].sub(\r\n            amount,\r\n            \"ERC20: burn amount exceeds balance\"\r\n        );\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\nfunction mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\nfunction toUint256Safe(int256 a) internal pure returns (uint256) {\r\n        require(a >= 0);\r\n        return uint256(a);\r\n    }\nfunction sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\nfunction div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\nfunction _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\nfunction add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }",
    "lines": [
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      93,
      94,
      139,
      140,
      141,
      142,
      143,
      144,
      145,
      70,
      71,
      72,
      159,
      160,
      161,
      162,
      171,
      172,
      173,
      174,
      175,
      130,
      131,
      132,
      133,
      134,
      135,
      136,
      137,
      668,
      669,
      670,
      671,
      672,
      673,
      674,
      675,
      676,
      677,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      123,
      164,
      165,
      166,
      167,
      147,
      148,
      149,
      150,
      151,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      107,
      108,
      109,
      110,
      17,
      18,
      19,
      112,
      113,
      114,
      153,
      154,
      155,
      156,
      157,
      96,
      97,
      98
    ],
    "name": "Dead-code",
    "exploit": "contract Contract{\n    function dead_code() internal() {}\n}\n",
    "description": "Functions that are not sued.",
    "recommendation": "Remove unused functions.",
    "explanation": "\n`dead_code` is not used in the contract, and make the code's review more difficult."
  },
  "Incorrect versions of Solidity": {
    "numberOfDuplicates": 1,
    "findType": "pragma",
    "title": "Pragma version0.8.9 (contracts/TestContract.sol#10) allows old versions\n\nsolc-0.8.9 is not recommended for deployment\n",
    "check": "solc-version",
    "impact": "Informational",
    "confidence": "High",
    "sourceTest": "pragma solidity 0.8.9;\n",
    "lines": [
      10
    ],
    "name": "Incorrect versions of Solidity",
    "exploit": "",
    "description": "`solc` frequently releases new compiler versions. Using an old version prevents access to new Solidity security checks.\nWe also recommend avoiding complex `pragma` statement.",
    "recommendation": "Deploy with any of the following Solidity versions:\n- 0.8.18\n\nThe recommendations take into account:\n- Risks related to recent releases\n- Risks of complex code generation changes\n- Risks of new language features\n- Risks of known bugs\n\nUse a simple pragma version that allows any of these versions.\nConsider using the latest version of Solidity for testing."
  },
  "Conformance to Solidity naming conventions": {
    "numberOfDuplicates": 5,
    "findType": "variable",
    "title": "Parameter XTwitter.changeMarketingWallet(address)._marketingWallet (contracts/TestContract.sol#785) is not in mixedCase\n\nFunction IUniswapV2Pair.PERMIT_TYPEHASH() (contracts/TestContract.sol#240) is not in mixedCase\n\nFunction IUniswapV2Pair.MINIMUM_LIQUIDITY() (contracts/TestContract.sol#271) is not in mixedCase\n\nFunction IUniswapV2Pair.DOMAIN_SEPARATOR() (contracts/TestContract.sol#238) is not in mixedCase\n\nFunction IUniswapV2Router01.WETH() (contracts/TestContract.sol#311) is not in mixedCase\n\nVariable XTwitter.DEAD (contracts/TestContract.sol#708) is not in mixedCase\n",
    "check": "naming-convention",
    "impact": "Informational",
    "confidence": "High",
    "sourceTest": "address _marketingWallet\nfunction PERMIT_TYPEHASH() external pure returns (bytes32);\nfunction MINIMUM_LIQUIDITY() external pure returns (uint);\nfunction DOMAIN_SEPARATOR() external view returns (bytes32);\nfunction WETH() external pure returns (address);\naddress private DEAD = 0x000000000000000000000000000000000000dEaD;",
    "lines": [
      785,
      240,
      271,
      238,
      311,
      708
    ],
    "name": "Conformance to Solidity naming conventions",
    "exploit": "",
    "description": "Solidity defines a [naming convention](https://solidity.readthedocs.io/en/v0.4.25/style-guide.html#naming-conventions) that should be followed.",
    "recommendation": "Follow the Solidity [naming convention](https://solidity.readthedocs.io/en/v0.4.25/style-guide.html#naming-conventions)."
  },
  "Variable names too similar": {
    "numberOfDuplicates": 0,
    "findType": "variable",
    "title": "Variable IUniswapV2Router01.addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256).amountADesired (contracts/TestContract.sol#316) is too similar to IUniswapV2Router01.addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256).amountBDesired (contracts/TestContract.sol#317)\n",
    "check": "similar-names",
    "impact": "Informational",
    "confidence": "Medium",
    "sourceTest": "uint amountADesired,",
    "lines": [
      316
    ],
    "name": "Variable names too similar",
    "exploit": "Bob uses several variables with similar names. As a result, his code is difficult to review.",
    "description": "Detect variables with names that are too similar.",
    "recommendation": "Prevent variables from having similar names."
  },
  "Unused state variable": {
    "numberOfDuplicates": 0,
    "findType": "variable",
    "title": "SafeMathInt.MAX_INT256 (contracts/TestContract.sol#128) is never used in SafeMathInt (contracts/TestContract.sol#126-168)\n",
    "check": "unused-state",
    "impact": "Informational",
    "confidence": "High",
    "sourceTest": "int256 private constant MAX_INT256 = ~(int256(1) << 255);",
    "lines": [
      128
    ],
    "name": "Unused state variable",
    "exploit": "",
    "description": "Unused state variable.",
    "recommendation": "Remove unused state variables."
  },
  "State variables that could be declared constant": {
    "numberOfDuplicates": 2,
    "findType": "variable",
    "title": "XTwitter.swapEnabled (contracts/TestContract.sol#712) should be constant \n\nXTwitter.DEAD (contracts/TestContract.sol#708) should be constant \n\nXTwitter.pinkLock (contracts/TestContract.sol#699) should be constant \n",
    "check": "constable-states",
    "impact": "Optimization",
    "confidence": "High",
    "sourceTest": "bool public swapEnabled = true;\naddress private DEAD = 0x000000000000000000000000000000000000dEaD;\naddress public pinkLock = 0x407993575c91ce7643a4d4cCACc9A98c36eE1BBE;",
    "lines": [
      712,
      708,
      699
    ],
    "name": "State variables that could be declared constant",
    "exploit": "",
    "description": "State variables that are not updated following deployment should be declared constant to save gas.",
    "recommendation": "Add the `constant` attribute to state variables that never change."
  },
  "State variables that could be declared immutable": {
    "numberOfDuplicates": 3,
    "findType": "variable",
    "title": "XTwitter.uniswapV2Router (contracts/TestContract.sol#705) should be immutable \n\nXTwitter.swapTokensAtAmount (contracts/TestContract.sol#711) should be immutable \n\nXTwitter.uniswapV2Pair (contracts/TestContract.sol#706) should be immutable \n\nXTwitter.antiBotBlockAmount (contracts/TestContract.sol#702) should be immutable \n",
    "check": "immutable-states",
    "impact": "Optimization",
    "confidence": "High",
    "sourceTest": "IUniswapV2Router02 public uniswapV2Router;\nuint256 public swapTokensAtAmount;\naddress public uniswapV2Pair;\nuint256 public antiBotBlockAmount;",
    "lines": [
      705,
      711,
      706,
      702
    ],
    "name": "State variables that could be declared immutable",
    "exploit": "",
    "description": "State variables that are not updated following deployment should be declared immutable to save gas.",
    "recommendation": "Add the `immutable` attribute to state variables that never change or are set only in the constructor."
  }
}