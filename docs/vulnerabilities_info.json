{
  "abiencoderv2-array": {
    "name": "Storage ABIEncoderV2 Array",
    "check": "abiencoderv2-array",
    "description": "`solc` versions `0.4.7`-`0.5.9` contain a [compiler bug](https://blog.ethereum.org/2019/06/25/solidity-storage-array-bugs) leading to incorrect ABI encoder usage.",
    "exploit": "contract A {\n    uint[2][3] bad_arr = [[1, 2], [3, 4], [5, 6]];\n    \n    /* Array of arrays passed to abi.encode is vulnerable */\n    function bad() public {                                                                                          \n        bytes memory b = abi.encode(bad_arr);\n    }\n}\n",
    "recommendation": "Use a compiler >= `0.5.10`.",
    "explanation": "\n`abi.encode(bad_arr)` in a call to `bad()` will incorrectly encode the array as `[[1, 2], [2, 3], [3, 4]]` and lead to unintended behavior."
  },
  "arbitrary-send-erc20": {
    "name": "Arbitrary `from` in transferFrom",
    "check": "arbitrary-send-erc20",
    "description": "Detect when `msg.sender` is not used as `from` in transferFrom.",
    "exploit": "    function a(address from, address to, uint256 amount) public {\n        erc20.transferFrom(from, to, am);\n    }\n",
    "recommendation": "Use `msg.sender` as `from` in transferFrom.",
    "explanation": "\nAlice approves this contract to spend her ERC20 tokens. Bob can call `a` and specify Alice's address as the `from` parameter in `transferFrom`, allowing him to transfer Alice's tokens to himself."
  },
  "array-by-reference": {
    "name": "Modifying storage array by value",
    "check": "array-by-reference",
    "description": "Detect arrays passed to a function that expects reference to a storage array",
    "exploit": "contract Memory {\n    uint[1] public x; // storage\n\n    function f() public {\n        f1(x); // update x\n        f2(x); // do not update x\n    }\n\n    function f1(uint[1] storage arr) internal { // by reference\n        arr[0] = 1;\n    }\n\n    function f2(uint[1] arr) internal { // by value\n        arr[0] = 2;\n    }\n}\n",
    "recommendation": "Ensure the correct usage of `memory` and `storage` in the function parameters. Make all the locations explicit.",
    "explanation": "\n\nBob calls `f()`. Bob assumes that at the end of the call `x[0]` is 2, but it is 1.\nAs a result, Bob's usage of the contract is incorrect."
  },
  "encode-packed-collision": {
    "name": "ABI encodePacked Collision",
    "check": "encode-packed-collision",
    "description": "Detect collision due to dynamic type usages in `abi.encodePacked`",
    "exploit": "contract Sign {\n    function get_hash_for_signature(string name, string doc) external returns(bytes32) {\n        return keccak256(abi.encodePacked(name, doc));\n    }\n}\n",
    "recommendation": "Do not use more than one dynamic type in `abi.encodePacked()`\n(see the [Solidity documentation](https://solidity.readthedocs.io/en/v0.5.10/abi-spec.html?highlight=abi.encodePacked#non-standard-packed-modeDynamic)). \nUse `abi.encode()`, preferably.",
    "explanation": "\nBob calls `get_hash_for_signature` with (`bob`, `This is the content`). The hash returned is used as an ID.\nEve creates a collision with the ID using (`bo`, `bThis is the content`) and compromises the system."
  },
  "incorrect-shift": {
    "name": "Incorrect shift in assembly.",
    "check": "incorrect-shift",
    "description": "Detect if the values in a shift operation are reversed",
    "exploit": "contract C {\n    function f() internal returns (uint a) {\n        assembly {\n            a := shr(a, 8)\n        }\n    }\n}\n",
    "recommendation": "Swap the order of parameters.",
    "explanation": "\nThe shift statement will right-shift the constant 8 by `a` bits"
  },
  "multiple-constructors": {
    "name": "Multiple constructor schemes",
    "check": "multiple-constructors",
    "description": "Detect multiple constructor definitions in the same contract (using new and old schemes).",
    "exploit": "contract A {\n    uint x;\n    constructor() public {\n        x = 0;\n    }\n    function A() public {\n        x = 1;\n    }\n    \n    function test() public returns(uint) {\n        return x;\n    }\n}\n",
    "recommendation": "Only declare one constructor, preferably using the new scheme `constructor(...)` instead of `function <contractName>(...)`.",
    "explanation": "\nIn Solidity [0.4.22](https://github.com/ethereum/solidity/releases/tag/v0.4.23), a contract with both constructor schemes will compile. The first constructor will take precedence over the second, which may be unintended."
  },
  "name-reused": {
    "name": "Name reused",
    "check": "name-reused",
    "description": "If a codebase has two contracts the similar names, the compilation artifacts\nwill not contain one of the contracts with the duplicate name.",
    "exploit": "Bob's `truffle` codebase has two contracts named `ERC20`.\nWhen `truffle compile` runs, only one of the two contracts will generate artifacts in `build/contracts`.\nAs a result, the second contract cannot be analyzed.",
    "recommendation": "Rename the contract."
  },
  "protected-vars": {
    "name": "Protected Variables",
    "check": "protected-vars",
    "description": "Detect unprotected variable that are marked protected",
    "exploit": "contract Buggy{\n\n    /// @custom:security write-protection=\"onlyOwner()\"\n    address owner;\n\n    function set_protected() public onlyOwner(){\n        owner = msg.sender;\n    }\n\n    function set_not_protected() public{\n        owner = msg.sender;\n    }\n}    \n",
    "recommendation": "Add access controls to the vulnerable function",
    "explanation": "\n`owner` must be always written by function using `onlyOwner` (`write-protection=\"onlyOwner()\"`), however anyone can call `set_not_protected`."
  },
  "public-mappings-nested": {
    "name": "Public mappings with nested variables",
    "check": "public-mappings-nested",
    "description": "Prior to Solidity 0.5, a public mapping with nested structures returned [incorrect values](https://github.com/ethereum/solidity/issues/5520).",
    "exploit": "Bob interacts with a contract that has a public mapping with nested structures. The values returned by the mapping are incorrect, breaking Bob's usage",
    "recommendation": "Do not use public mapping with nested structures."
  },
  "rtlo": {
    "name": "Right-to-Left-Override character",
    "check": "rtlo",
    "description": "An attacker can manipulate the logic of the contract by using a right-to-left-override character (`U+202E)`.",
    "exploit": "contract Token\n{\n\n    address payable o; // owner\n    mapping(address => uint) tokens;\n\n    function withdraw() external returns(uint)\n    {\n        uint amount = tokens[msg.sender];\n        address payable d = msg.sender;\n        tokens[msg.sender] = 0;\n        _withdraw(/*owner‮/*noitanitsed*/ d, o/*‭\n\t\t        /*value */, amount);\n    }\n\n    function _withdraw(address payable fee_receiver, address payable destination, uint value) internal\n    {\n\t\tfee_receiver.transfer(1);\n\t\tdestination.transfer(value);\n    }\n}\n",
    "recommendation": "Special control characters must not be allowed.",
    "explanation": "\n\n`Token` uses the right-to-left-override character when calling `_withdraw`. As a result, the fee is incorrectly sent to `msg.sender`, and the token balance is sent to the owner."
  },
  "shadowing-state": {
    "name": "State variable shadowing",
    "check": "shadowing-state",
    "description": "Detection of state variables shadowed.",
    "exploit": "contract BaseContract{\n    address owner;\n\n    modifier isOwner(){\n        require(owner == msg.sender);\n        _;\n    }\n\n}\n\ncontract DerivedContract is BaseContract{\n    address owner;\n\n    constructor(){\n        owner = msg.sender;\n    }\n\n    function withdraw() isOwner() external{\n        msg.sender.transfer(this.balance);\n    }\n}\n",
    "recommendation": "Remove the state variable shadowing.",
    "explanation": "\n`owner` of `BaseContract` is never assigned and the modifier `isOwner` does not work."
  },
  "suicidal": {
    "name": "Suicidal",
    "check": "suicidal",
    "description": "Unprotected call to a function executing `selfdestruct`/`suicide`.",
    "exploit": "contract Suicidal{\n    function kill() public{\n        selfdestruct(msg.sender);\n    }\n}\n",
    "recommendation": "Protect access to all sensitive functions.",
    "explanation": "\nBob calls `kill` and destructs the contract."
  },
  "uninitialized-state": {
    "name": "Uninitialized state variables",
    "check": "uninitialized-state",
    "description": "Uninitialized state variables.",
    "exploit": "contract Uninitialized{\n    address destination;\n\n    function transfer() payable public{\n        destination.transfer(msg.value);\n    }\n}\n",
    "recommendation": "Initialize all the variables. If a variable is meant to be initialized to zero, explicitly set it to zero to improve code readability.",
    "explanation": "\nBob calls `transfer`. As a result, the Ether are sent to the address `0x0` and are lost."
  },
  "uninitialized-storage": {
    "name": "Uninitialized storage variables",
    "check": "uninitialized-storage",
    "description": "An uninitialized storage variable will act as a reference to the first state variable, and can override a critical variable.",
    "exploit": "contract Uninitialized{\n    address owner = msg.sender;\n\n    struct St{\n        uint a;\n    }\n\n    function func() {\n        St st;\n        st.a = 0x0;\n    }\n}\n",
    "recommendation": "Initialize all storage variables.",
    "explanation": "\nBob calls `func`. As a result, `owner` is overridden to `0`."
  },
  "unprotected-upgrade": {
    "name": "Unprotected upgradeable contract",
    "check": "unprotected-upgrade",
    "description": "Detects logic contract that can be destructed.",
    "exploit": "contract Buggy is Initializable{\n    address payable owner;\n\n    function initialize() external initializer{\n        require(owner == address(0));\n        owner = msg.sender;\n    }\n    function kill() external{\n        require(msg.sender == owner);\n        selfdestruct(owner);\n    }\n}\n",
    "recommendation": "Add a constructor to ensure `initialize` cannot be called on the logic contract.",
    "explanation": "\nBuggy is an upgradeable contract. Anyone can call initialize on the logic contract, and destruct the contract."
  },
  "arbitrary-send-erc20-permit": {
    "name": "Arbitrary `from` in transferFrom used with permit",
    "check": "arbitrary-send-erc20-permit",
    "description": "Detect when `msg.sender` is not used as `from` in transferFrom and permit is used.",
    "exploit": "    function bad(address from, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) public {\n        erc20.permit(from, address(this), value, deadline, v, r, s);\n        erc20.transferFrom(from, to, value);\n    }\n",
    "recommendation": "Ensure that the underlying ERC20 token correctly implements a permit function.",
    "explanation": "\nIf an ERC20 token does not implement permit and has a fallback function e.g. WETH, transferFrom allows an attacker to transfer all tokens approved for this contract."
  },
  "arbitrary-send-eth": {
    "name": "Functions that send Ether to arbitrary destinations",
    "check": "arbitrary-send-eth",
    "description": "Unprotected call to a function sending Ether to an arbitrary address.",
    "exploit": "contract ArbitrarySendEth{\n    address destination;\n    function setDestination(){\n        destination = msg.sender;\n    }\n\n    function withdraw() public{\n        destination.transfer(this.balance);\n    }\n}\n",
    "recommendation": "Ensure that an arbitrary user cannot withdraw unauthorized funds.",
    "explanation": "\nBob calls `setDestination` and `withdraw`. As a result he withdraws the contract's balance."
  },
  "controlled-array-length": {
    "name": "Array Length Assignment",
    "check": "controlled-array-length",
    "description": "Detects the direct assignment of an array's length.",
    "exploit": "contract A {\n\tuint[] testArray; // dynamic size array\n\n\tfunction f(uint usersCount) public {\n\t\t// ...\n\t\ttestArray.length = usersCount;\n\t\t// ...\n\t}\n\n\tfunction g(uint userIndex, uint val) public {\n\t\t// ...\n\t\ttestArray[userIndex] = val;\n\t\t// ...\n\t}\n}\n",
    "recommendation": "Do not allow array lengths to be set directly set; instead, opt to add values as needed.\nOtherwise, thoroughly review the contract to ensure a user-controlled variable cannot reach an array length assignment.",
    "explanation": "\nContract storage/state-variables are indexed by a 256-bit integer.\nThe user can set the array length to `2**256-1` in order to index all storage slots. \nIn the example above, one could call the function `f` to set the array length, then call the function `g` to control any storage slot desired. \nNote that storage slots here are indexed via a hash of the indexers; nonetheless, all storage will still be accessible and could be controlled by the attacker."
  },
  "controlled-delegatecall": {
    "name": "Controlled Delegatecall",
    "check": "controlled-delegatecall",
    "description": "`Delegatecall` or `callcode` to an address controlled by the user.",
    "exploit": "contract Delegatecall{\n    function delegate(address to, bytes data){\n        to.delegatecall(data);\n    }\n}\n",
    "recommendation": "Avoid using `delegatecall`. Use only trusted destinations.",
    "explanation": "\nBob calls `delegate` and delegates the execution to his malicious contract. As a result, Bob withdraws the funds of the contract and destructs it."
  },
  "delegatecall-loop": {
    "name": "Payable functions using `delegatecall` inside a loop",
    "check": "delegatecall-loop",
    "description": "Detect the use of `delegatecall` inside a loop in a payable function.",
    "exploit": "contract DelegatecallInLoop{\n\n    mapping (address => uint256) balances;\n\n    function bad(address[] memory receivers) public payable {\n        for (uint256 i = 0; i < receivers.length; i++) {\n            address(this).delegatecall(abi.encodeWithSignature(\"addBalance(address)\", receivers[i]));\n        }\n    }\n\n    function addBalance(address a) public payable {\n        balances[a] += msg.value;\n    } \n\n}\n",
    "recommendation": "Carefully check that the function called by `delegatecall` is not payable/doesn't use `msg.value`.",
    "explanation": "\nWhen calling `bad` the same `msg.value` amount will be accredited multiple times."
  },
  "incorrect-exp": {
    "name": "Incorrect exponentiation",
    "check": "incorrect-exp",
    "description": "Detect use of bitwise `xor ^` instead of exponential `**`",
    "exploit": "contract Bug{\n    uint UINT_MAX = 2^256 - 1;\n    ...\n}\n",
    "recommendation": "Use the correct operator `**` for exponentiation.",
    "explanation": "\nAlice deploys a contract in which `UINT_MAX` incorrectly uses `^` operator instead of `**` for exponentiation"
  },
  "incorrect-return": {
    "name": "Incorrect return in assembly",
    "check": "incorrect-return",
    "description": "Detect if `return` in an assembly block halts unexpectedly the execution.",
    "exploit": "contract C {\n    function f() internal returns (uint a, uint b) {\n        assembly {\n            return (5, 6)\n        }\n    }\n\n    function g() returns (bool){\n        f();\n        return true;\n    }\n}\n",
    "recommendation": "Use the `leave` statement.",
    "explanation": "\nThe return statement in `f` will cause execution in `g` to halt.\nThe function will return 6 bytes starting from offset 5, instead of returning a boolean."
  },
  "msg-value-loop": {
    "name": "`msg.value` inside a loop",
    "check": "msg-value-loop",
    "description": "Detect the use of `msg.value` inside a loop.",
    "exploit": "contract MsgValueInLoop{\n\n    mapping (address => uint256) balances;\n\n    function bad(address[] memory receivers) public payable {\n        for (uint256 i=0; i < receivers.length; i++) {\n            balances[receivers[i]] += msg.value;\n        }\n    }\n\n}\n",
    "recommendation": "Provide an explicit array of amounts alongside the receivers array, and check that the sum of all amounts matches `msg.value`.",
    "explanation": ""
  },
  "reentrancy-eth": {
    "name": "Reentrancy vulnerabilities",
    "check": "reentrancy-eth",
    "description": "Detection of the [reentrancy bug](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy).\nDo not report reentrancies that don't involve Ether (see `reentrancy-no-eth`)",
    "exploit": "    function withdrawBalance(){\n        // send userBalance[msg.sender] Ether to msg.sender\n        // if msg.sender is a contract, it will call its fallback function\n        if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n            throw;\n        }\n        userBalance[msg.sender] = 0;\n    }\n",
    "recommendation": "Apply the [`check-effects-interactions pattern`](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy).",
    "explanation": "\n\nBob uses the re-entrancy bug to call `withdrawBalance` two times, and withdraw more than its initial deposit to the contract."
  },
  "return-leave": {
    "name": "Return instead of leave in assembly",
    "check": "return-leave",
    "description": "Detect if a `return` is used where a `leave` should be used.",
    "exploit": "contract C {\n    function f() internal returns (uint a, uint b) {\n        assembly {\n            return (5, 6)\n        }\n    }\n\n}\n",
    "recommendation": "Use the `leave` statement.",
    "explanation": "\nThe function will halt the execution, instead of returning a two uint."
  },
  "storage-array": {
    "name": "Storage Signed Integer Array",
    "check": "storage-array",
    "description": "`solc` versions `0.4.7`-`0.5.9` contain [a compiler bug](https://blog.ethereum.org/2019/06/25/solidity-storage-array-bugs)\nleading to incorrect values in signed integer arrays.",
    "exploit": "contract A {\n\tint[3] ether_balances; // storage signed integer array\n\tfunction bad0() private {\n\t\t// ...\n\t\tether_balances = [-1, -1, -1];\n\t\t// ...\n\t}\n}\n",
    "recommendation": "Use a compiler version >= `0.5.10`.",
    "explanation": "\n`bad0()` uses a (storage-allocated) signed integer array state variable to store the ether balances of three accounts.  \n`-1` is supposed to indicate uninitialized values but the Solidity bug makes these as `1`, which could be exploited by the accounts."
  },
  "unchecked-transfer": {
    "name": "Unchecked transfer",
    "check": "unchecked-transfer",
    "description": "The return value of an external transfer/transferFrom call is not checked",
    "exploit": "contract Token {\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n}\ncontract MyBank{  \n    mapping(address => uint) balances;\n    Token token;\n    function deposit(uint amount) public{\n        token.transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    }\n}\n",
    "recommendation": "Use `SafeERC20`, or ensure that the transfer/transferFrom return value is checked.",
    "explanation": "\nSeveral tokens do not revert in case of failure and return false. If one of these tokens is used in `MyBank`, `deposit` will not revert if the transfer fails, and an attacker can call `deposit` for free.."
  },
  "weak-prng": {
    "name": "Weak PRNG",
    "check": "weak-prng",
    "description": "Weak PRNG due to a modulo on `block.timestamp`, `now` or `blockhash`. These can be influenced by miners to some extent so they should be avoided.",
    "exploit": "contract Game {\n\n    uint reward_determining_number;\n\n    function guessing() external{\n      reward_determining_number = uint256(block.blockhash(10000)) % 10;\n    }\n}\n",
    "recommendation": "Do not use `block.timestamp`, `now` or `blockhash` as a source of randomness",
    "explanation": "\nEve is a miner. Eve calls `guessing` and re-orders the block containing the transaction. \nAs a result, Eve wins the game."
  },
  "codex": {
    "name": "Codex",
    "check": "codex",
    "description": "Use [codex](https://openai.com/blog/openai-codex/) to find vulnerabilities",
    "exploit": "N/A",
    "recommendation": "Review codex's message."
  },
  "domain-separator-collision": {
    "name": "Domain separator collision",
    "check": "domain-separator-collision",
    "description": "An ERC20 token has a function whose signature collides with EIP-2612's DOMAIN_SEPARATOR(), causing unanticipated behavior for contracts using `permit` functionality.",
    "exploit": "contract Contract{\n    function some_collisions() external() {}\n}\n",
    "recommendation": "Remove or rename the function that collides with DOMAIN_SEPARATOR().",
    "explanation": "\n`some_collision` clashes with EIP-2612's DOMAIN_SEPARATOR() and will interfere with contract's using `permit`."
  },
  "enum-conversion": {
    "name": "Dangerous enum conversion",
    "check": "enum-conversion",
    "description": "Detect out-of-range `enum` conversion (`solc` < `0.4.5`).",
    "exploit": "    pragma solidity 0.4.2;\n    contract Test{\n\n    enum E{a}\n\n    function bug(uint a) public returns(E){\n        return E(a);\n    }\n}\n",
    "recommendation": "Use a recent compiler version. If `solc` <`0.4.5` is required, check the `enum` conversion range.",
    "explanation": "\nAttackers can trigger unexpected behaviour by calling `bug(1)`."
  },
  "erc20-interface": {
    "name": "Incorrect erc20 interface",
    "check": "erc20-interface",
    "description": "Incorrect return values for `ERC20` functions. A contract compiled with Solidity > 0.4.22 interacting with these functions will fail to execute them, as the return value is missing.",
    "exploit": "contract Token{\n    function transfer(address to, uint value) external;\n    //...\n}\n",
    "recommendation": "Set the appropriate return values and types for the defined `ERC20` functions.",
    "explanation": "\n`Token.transfer` does not return a boolean. Bob deploys the token. Alice creates a contract that interacts with it but assumes a correct `ERC20` interface implementation. Alice's contract is unable to interact with Bob's contract."
  },
  "erc721-interface": {
    "name": "Incorrect erc721 interface",
    "check": "erc721-interface",
    "description": "Incorrect return values for `ERC721` functions. A contract compiled with solidity > 0.4.22 interacting with these functions will fail to execute them, as the return value is missing.",
    "exploit": "contract Token{\n    function ownerOf(uint256 _tokenId) external view returns (bool);\n    //...\n}\n",
    "recommendation": "Set the appropriate return values and vtypes for the defined `ERC721` functions.",
    "explanation": "\n`Token.ownerOf` does not return an address like `ERC721` expects. Bob deploys the token. Alice creates a contract that interacts with it but assumes a correct `ERC721` interface implementation. Alice's contract is unable to interact with Bob's contract."
  },
  "incorrect-equality": {
    "name": "Dangerous strict equalities",
    "check": "incorrect-equality",
    "description": "Use of strict equalities that can be easily manipulated by an attacker.",
    "exploit": "contract Crowdsale{\n    function fund_reached() public returns(bool){\n        return this.balance == 100 ether;\n    }\n",
    "recommendation": "Don't use strict equality to determine if an account has enough Ether or tokens.",
    "explanation": "\n`Crowdsale` relies on `fund_reached` to know when to stop the sale of tokens.\n`Crowdsale` reaches 100 Ether. Bob sends 0.1 Ether. As a result, `fund_reached` is always false and the `crowdsale` never ends."
  },
  "locked-ether": {
    "name": "Contracts that lock Ether",
    "check": "locked-ether",
    "description": "Contract with a `payable` function, but without a withdrawal capacity.",
    "exploit": "pragma solidity 0.4.24;\ncontract Locked{\n    function receive() payable public{\n    }\n}\n",
    "recommendation": "Remove the payable attribute or add a withdraw function.",
    "explanation": "\nEvery Ether sent to `Locked` will be lost."
  },
  "mapping-deletion": {
    "name": "Deletion on mapping containing a structure",
    "check": "mapping-deletion",
    "description": "A deletion in a structure containing a mapping will not delete the mapping (see the [Solidity documentation](https://solidity.readthedocs.io/en/latest/types.html##delete)). The remaining data may be used to compromise the contract.",
    "exploit": "    struct BalancesStruct{\n        address owner;\n        mapping(address => uint) balances;\n    }\n    mapping(address => BalancesStruct) public stackBalance;\n\n    function remove() internal{\n         delete stackBalance[msg.sender];\n    }\n",
    "recommendation": "Use a lock mechanism instead of a deletion to disable structure containing a mapping.",
    "explanation": "\n`remove` deletes an item of `stackBalance`.\nThe mapping `balances` is never deleted, so `remove` does not work as intended."
  },
  "shadowing-abstract": {
    "name": "State variable shadowing from abstract contracts",
    "check": "shadowing-abstract",
    "description": "Detection of state variables shadowed from abstract contracts.",
    "exploit": "contract BaseContract{\n    address owner;\n}\n\ncontract DerivedContract is BaseContract{\n    address owner;\n}\n",
    "recommendation": "Remove the state variable shadowing.",
    "explanation": "\n`owner` of `BaseContract` is shadowed in `DerivedContract`."
  },
  "tautological-compare": {
    "name": "Tautological compare",
    "check": "tautological-compare",
    "description": "A variable compared to itself is probably an error as it will always return `true` for `==`, `>=`, `<=` and always `false` for `<`, `>` and `!=`.",
    "exploit": "    function check(uint a) external returns(bool){\n        return (a >= a);\n    }\n",
    "recommendation": "Remove comparison or compare to different value.",
    "explanation": "\n`check` always return true."
  },
  "tautology": {
    "name": "Tautology or contradiction",
    "check": "tautology",
    "description": "Detects expressions that are tautologies or contradictions.",
    "exploit": "contract A {\n\tfunction f(uint x) public {\n\t\t// ...\n        if (x >= 0) { // bad -- always true\n           // ...\n        }\n\t\t// ...\n\t}\n\n\tfunction g(uint8 y) public returns (bool) {\n\t\t// ...\n        return (y < 512); // bad!\n\t\t// ...\n\t}\n}\n",
    "recommendation": "Fix the incorrect comparison by changing the value type or the comparison.",
    "explanation": "\n`x` is a `uint256`, so `x >= 0` will be always true.\n`y` is a `uint8`, so `y <512` will be always true."
  },
  "write-after-write": {
    "name": "Write after write",
    "check": "write-after-write",
    "description": "Detects variables that are written but never read and written again.",
    "exploit": "    contract Buggy{\n        function my_func() external initializer{\n            // ...\n            a = b;\n            a = c;\n            // ..\n        }\n    }\n    ",
    "recommendation": "Fix or remove the writes.",
    "explanation": "\n    `a` is first asigned to `b`, and then to `c`. As a result the first write does nothing."
  },
  "boolean-cst": {
    "name": "Misuse of a Boolean constant",
    "check": "boolean-cst",
    "description": "Detects the misuse of a Boolean constant.",
    "exploit": "contract A {\n\tfunction f(uint x) public {\n\t\t// ...\n        if (false) { // bad!\n           // ...\n        }\n\t\t// ...\n\t}\n\n\tfunction g(bool b) public returns (bool) {\n\t\t// ...\n        return (b || true); // bad!\n\t\t// ...\n\t}\n}\n",
    "recommendation": "Verify and simplify the condition.",
    "explanation": "\nBoolean constants in code have only a few legitimate uses. \nOther uses (in complex expressions, as conditionals) indicate either an error or, most likely, the persistence of faulty code."
  },
  "constant-function-asm": {
    "name": "Constant functions using assembly code",
    "check": "constant-function-asm",
    "description": "Functions declared as `constant`/`pure`/`view` using assembly code.\n\n`constant`/`pure`/`view` was not enforced prior to Solidity 0.5.\nStarting from Solidity 0.5, a call to a `constant`/`pure`/`view` function uses the `STATICCALL` opcode, which reverts in case of state modification.\n\nAs a result, a call to an [incorrectly labeled function may trap a contract compiled with Solidity 0.5](https://solidity.readthedocs.io/en/develop/050-breaking-changes.html#interoperability-with-older-contracts).",
    "exploit": "contract Constant{\n    uint counter;\n    function get() public view returns(uint){\n       counter = counter +1;\n       return counter\n    }\n}\n",
    "recommendation": "Ensure the attributes of contracts compiled prior to Solidity 0.5.0 are correct.",
    "explanation": "\n`Constant` was deployed with Solidity 0.4.25. Bob writes a smart contract that interacts with `Constant` in Solidity 0.5.0. \nAll the calls to `get` revert, breaking Bob's smart contract execution."
  },
  "constant-function-state": {
    "name": "Constant functions changing the state",
    "check": "constant-function-state",
    "description": "Functions declared as `constant`/`pure`/`view` change the state.\n\n`constant`/`pure`/`view` was not enforced prior to Solidity 0.5.\nStarting from Solidity 0.5, a call to a `constant`/`pure`/`view` function uses the `STATICCALL` opcode, which reverts in case of state modification.\n\nAs a result, a call to an [incorrectly labeled function may trap a contract compiled with Solidity 0.5](https://solidity.readthedocs.io/en/develop/050-breaking-changes.html#interoperability-with-older-contracts).",
    "exploit": "contract Constant{\n    uint counter;\n    function get() public view returns(uint){\n       counter = counter +1;\n       return counter\n    }\n}\n",
    "recommendation": "Ensure that attributes of contracts compiled prior to Solidity 0.5.0 are correct.",
    "explanation": "\n`Constant` was deployed with Solidity 0.4.25. Bob writes a smart contract that interacts with `Constant` in Solidity 0.5.0. \nAll the calls to `get` revert, breaking Bob's smart contract execution."
  },
  "divide-before-multiply": {
    "name": "Divide before multiply",
    "check": "divide-before-multiply",
    "description": "Solidity's integer division truncates. Thus, performing division before multiplication can lead to precision loss.",
    "exploit": "contract A {\n\tfunction f(uint n) public {\n        coins = (oldSupply / n) * interest;\n    }\n}\n",
    "recommendation": "Consider ordering multiplication before division.",
    "explanation": "\nIf `n` is greater than `oldSupply`, `coins` will be zero. For example, with `oldSupply = 5; n = 10, interest = 2`, coins will be zero.  \nIf `(oldSupply * interest / n)` was used, `coins` would have been `1`.   \nIn general, it's usually a good idea to re-arrange arithmetic to perform multiplication before division, unless the limit of a smaller type makes this dangerous."
  },
  "reentrancy-no-eth": {
    "name": "Reentrancy vulnerabilities",
    "check": "reentrancy-no-eth",
    "description": "Detection of the [reentrancy bug](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy).\nDo not report reentrancies that involve Ether (see `reentrancy-eth`).",
    "exploit": "    function bug(){\n        require(not_called);\n        if( ! (msg.sender.call() ) ){\n            throw;\n        }\n        not_called = False;\n    }   \n",
    "recommendation": "Apply the [`check-effects-interactions` pattern](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy).",
    "explanation": ""
  },
  "reused-constructor": {
    "name": "Reused base constructors",
    "check": "reused-constructor",
    "description": "Detects if the same base constructor is called with arguments from two different locations in the same inheritance hierarchy.",
    "exploit": "pragma solidity ^0.4.0;\n\ncontract A{\n    uint num = 5;\n    constructor(uint x) public{\n        num += x;\n    }\n}\n\ncontract B is A{\n    constructor() A(2) public { /* ... */ }\n}\n\ncontract C is A {\n    constructor() A(3) public { /* ... */ }\n}\n\ncontract D is B, C {\n    constructor() public { /* ... */ }\n}\n\ncontract E is B {\n    constructor() A(1) public { /* ... */ }\n}\n",
    "recommendation": "Remove the duplicate constructor call.",
    "explanation": "\nThe constructor of `A` is called multiple times in `D` and `E`:\n- `D` inherits from `B` and `C`, both of which construct `A`.\n- `E` only inherits from `B`, but `B` and `E` construct `A`.\n."
  },
  "tx-origin": {
    "name": "Dangerous usage of `tx.origin`",
    "check": "tx-origin",
    "description": "`tx.origin`-based protection can be abused by a malicious contract if a legitimate user interacts with the malicious contract.",
    "exploit": "contract TxOrigin {\n    address owner = msg.sender;\n\n    function bug() {\n        require(tx.origin == owner);\n    }\n",
    "recommendation": "Do not use `tx.origin` for authorization.",
    "explanation": "\nBob is the owner of `TxOrigin`. Bob calls Eve's contract. Eve's contract calls `TxOrigin` and bypasses the `tx.origin` protection."
  },
  "unchecked-lowlevel": {
    "name": "Unchecked low-level calls",
    "check": "unchecked-lowlevel",
    "description": "The return value of a low-level call is not checked.",
    "exploit": "contract MyConc{\n    function my_func(address payable dst) public payable{\n        dst.call.value(msg.value)(\"\");\n    }\n}\n",
    "recommendation": "Ensure that the return value of a low-level call is checked or logged.",
    "explanation": "\nThe return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract.\nIf the low level is used to prevent blocking operations, consider logging failed calls."
  },
  "unchecked-send": {
    "name": "Unchecked Send",
    "check": "unchecked-send",
    "description": "The return value of a `send` is not checked.",
    "exploit": "contract MyConc{\n    function my_func(address payable dst) public payable{\n        dst.send(msg.value);\n    }\n}\n",
    "recommendation": "Ensure that the return value of `send` is checked or logged.",
    "explanation": "\nThe return value of `send` is not checked, so if the send fails, the Ether will be locked in the contract.\nIf `send` is used to prevent blocking operations, consider logging the failed `send`."
  },
  "uninitialized-local": {
    "name": "Uninitialized local variables",
    "check": "uninitialized-local",
    "description": "Uninitialized local variables.",
    "exploit": "contract Uninitialized is Owner{\n    function withdraw() payable public onlyOwner{\n        address to;\n        to.transfer(this.balance)\n    }\n}\n",
    "recommendation": "Initialize all the variables. If a variable is meant to be initialized to zero, explicitly set it to zero to improve code readability.",
    "explanation": "\nBob calls `transfer`. As a result, all Ether is sent to the address `0x0` and is lost."
  },
  "unused-return": {
    "name": "Unused return",
    "check": "unused-return",
    "description": "The return value of an external call is not stored in a local or state variable.",
    "exploit": "contract MyConc{\n    using SafeMath for uint;   \n    function my_func(uint a, uint b) public{\n        a.add(b);\n    }\n}\n",
    "recommendation": "Ensure that all the return values of the function calls are used.",
    "explanation": "\n`MyConc` calls `add` of `SafeMath`, but does not store the result in `a`. As a result, the computation has no effect."
  },
  "incorrect-modifier": {
    "name": "Incorrect modifier",
    "check": "incorrect-modifier",
    "description": "If a modifier does not execute `_` or revert, the execution of the function will return the default value, which can be misleading for the caller.",
    "exploit": "    modidfier myModif(){\n        if(..){\n           _;\n        }\n    }\n    function get() myModif returns(uint){\n\n    }\n",
    "recommendation": "All the paths in a modifier must execute `_` or revert.",
    "explanation": "\nIf the condition in `myModif` is false, the execution of `get()` will return 0."
  },
  "shadowing-builtin": {
    "name": "Builtin Symbol Shadowing",
    "check": "shadowing-builtin",
    "description": "Detection of shadowing built-in symbols using local variables, state variables, functions, modifiers, or events.",
    "exploit": "pragma solidity ^0.4.24;\n\ncontract Bug {\n    uint now; // Overshadows current time stamp.\n\n    function assert(bool condition) public {\n        // Overshadows built-in symbol for providing assertions.\n    }\n\n    function get_next_expiration(uint earlier_time) private returns (uint) {\n        return now + 259200; // References overshadowed timestamp.\n    }\n}\n",
    "recommendation": "Rename the local variables, state variables, functions, modifiers, and events that shadow a builtin symbol.",
    "explanation": "\n`now` is defined as a state variable, and shadows with the built-in symbol `now`. The function `assert` overshadows the built-in `assert` function. Any use of either of these built-in symbols may lead to unexpected results."
  },
  "shadowing-local": {
    "name": "Local variable shadowing",
    "check": "shadowing-local",
    "description": "Detection of shadowing using local variables.",
    "exploit": "pragma solidity ^0.4.24;\n\ncontract Bug {\n    uint owner;\n\n    function sensitive_function(address owner) public {\n        // ...\n        require(owner == msg.sender);\n    }\n\n    function alternate_sensitive_function() public {\n        address owner = msg.sender;\n        // ...\n        require(owner == msg.sender);\n    }\n}\n",
    "recommendation": "Rename the local variables that shadow another component.",
    "explanation": "\n`sensitive_function.owner` shadows `Bug.owner`. As a result, the use of `owner` in `sensitive_function` might be incorrect."
  },
  "uninitialized-fptr-cst": {
    "name": "Uninitialized function pointers in constructors",
    "check": "uninitialized-fptr-cst",
    "description": "solc versions `0.4.5`-`0.4.26` and `0.5.0`-`0.5.8` contain a compiler bug leading to unexpected behavior when calling uninitialized function pointers in constructors.",
    "exploit": "contract bad0 {\n\n  constructor() public {\n    /* Uninitialized function pointer */\n    function(uint256) internal returns(uint256) a;\n    a(10);\n  }\n\n}\n",
    "recommendation": "Initialize function pointers before calling. Avoid function pointers if possible.",
    "explanation": "\nThe call to `a(10)` will lead to unexpected behavior because function pointer `a` is not initialized in the constructor."
  },
  "variable-scope": {
    "name": "Pre-declaration usage of local variables",
    "check": "variable-scope",
    "description": "Detects the possible usage of a variable before the declaration is stepped over (either because it is later declared, or declared in another scope).",
    "exploit": "contract C {\n    function f(uint z) public returns (uint) {\n        uint y = x + 9 + z; // 'z' is used pre-declaration\n        uint x = 7;\n\n        if (z % 2 == 0) {\n            uint max = 5;\n            // ...\n        }\n\n        // 'max' was intended to be 5, but it was mistakenly declared in a scope and not assigned (so it is zero).\n        for (uint i = 0; i < max; i++) {\n            x += 1;\n        }\n\n        return x;\n    }\n}\n",
    "recommendation": "Move all variable declarations prior to any usage of the variable, and ensure that reaching a variable declaration does not depend on some conditional if it is used unconditionally.",
    "explanation": "\nIn the case above, the variable `x` is used before its declaration, which may result in unintended consequences. \nAdditionally, the for-loop uses the variable `max`, which is declared in a previous scope that may not always be reached. This could lead to unintended consequences if the user mistakenly uses a variable prior to any intended declaration assignment. It also may indicate that the user intended to reference a different variable."
  },
  "void-cst": {
    "name": "Void constructor",
    "check": "void-cst",
    "description": "Detect the call to a constructor that is not implemented",
    "exploit": "contract A{}\ncontract B is A{\n    constructor() public A(){}\n}\n",
    "recommendation": "Remove the constructor call.",
    "explanation": "\nWhen reading `B`'s constructor definition, we might assume that `A()` initiates the contract, but no code is executed."
  },
  "calls-loop": {
    "name": "Calls inside a loop",
    "check": "calls-loop",
    "description": "Calls inside a loop might lead to a denial-of-service attack.",
    "exploit": "contract CallsInLoop{\n\n    address[] destinations;\n\n    constructor(address[] newDestinations) public{\n        destinations = newDestinations;\n    }\n\n    function bad() external{\n        for (uint i=0; i < destinations.length; i++){\n            destinations[i].transfer(i);\n        }\n    }\n\n}\n",
    "recommendation": "Favor [pull over push](https://github.com/ethereum/wiki/wiki/Safety#favor-pull-over-push-for-external-calls) strategy for external calls.",
    "explanation": "\nIf one of the destinations has a fallback function that reverts, `bad` will always revert."
  },
  "events-access": {
    "name": "Missing events access control",
    "check": "events-access",
    "description": "Detect missing events for critical access control parameters",
    "exploit": "contract C {\n\n  modifier onlyAdmin {\n    if (msg.sender != owner) throw;\n    _;\n  }\n\n  function updateOwner(address newOwner) onlyAdmin external {\n    owner = newOwner;\n  }\n}\n",
    "recommendation": "Emit an event for critical parameter changes.",
    "explanation": "\n`updateOwner()` has no event, so it is difficult to track off-chain owner changes."
  },
  "events-maths": {
    "name": "Missing events arithmetic",
    "check": "events-maths",
    "description": "Detect missing events for critical arithmetic parameters.",
    "exploit": "contract C {\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _;\n    }\n\n    function setBuyPrice(uint256 newBuyPrice) onlyOwner public {\n        buyPrice = newBuyPrice;\n    }\n\n    function buy() external {\n     ... // buyPrice is used to determine the number of tokens purchased\n    }    \n}\n",
    "recommendation": "Emit an event for critical parameter changes.",
    "explanation": "\n`setBuyPrice()` does not emit an event, so it is difficult to track changes in the value of `buyPrice` off-chain."
  },
  "incorrect-unary": {
    "name": "Dangerous unary expressions",
    "check": "incorrect-unary",
    "description": "Unary expressions such as `x=+1` probably typos.",
    "exploit": "",
    "recommendation": "Remove the unary expression.",
    "explanation": "Solidity \ncontract Bug{\n    uint public counter;\n\n    function increase() public returns(uint){\n        counter=+1;\n        return counter;\n    }\n}\n"
  },
  "missing-zero-check": {
    "name": "Missing zero address validation",
    "check": "missing-zero-check",
    "description": "Detect missing zero address validation.",
    "exploit": "contract C {\n\n  modifier onlyAdmin {\n    if (msg.sender != owner) throw;\n    _;\n  }\n\n  function updateOwner(address newOwner) onlyAdmin external {\n    owner = newOwner;\n  }\n}\n",
    "recommendation": "Check that the address is not zero.",
    "explanation": "\nBob calls `updateOwner` without specifying the `newOwner`, so Bob loses ownership of the contract."
  },
  "reentrancy-benign": {
    "name": "Reentrancy vulnerabilities",
    "check": "reentrancy-benign",
    "description": "Detection of the [reentrancy bug](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy).\nOnly report reentrancy that acts as a double call (see `reentrancy-eth`, `reentrancy-no-eth`).",
    "exploit": "    function callme(){\n        if( ! (msg.sender.call()() ) ){\n            throw;\n        }\n        counter += 1\n    }   \n",
    "recommendation": "Apply the [`check-effects-interactions` pattern](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy).",
    "explanation": "\n\n`callme` contains a reentrancy. The reentrancy is benign because it's exploitation would have the same effect as two consecutive calls."
  },
  "reentrancy-events": {
    "name": "Reentrancy vulnerabilities",
    "check": "reentrancy-events",
    "description": "Detects [reentrancies](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy) that allow manipulation of the order or value of events.",
    "exploit": "contract ReentrantContract {\n\tfunction f() external {\n\t\tif (BugReentrancyEvents(msg.sender).counter() == 1) {\n\t\t\tBugReentrancyEvents(msg.sender).count(this);\n\t\t}\n\t}\n}\ncontract Counter {\n\tuint public counter;\n\tevent Counter(uint);\n\n}\ncontract BugReentrancyEvents is Counter {\n    function count(ReentrantContract d) external {\n        counter += 1;\n        d.f();\n        emit Counter(counter);\n    }\n}\ncontract NoReentrancyEvents is Counter {\n\tfunction count(ReentrantContract d) external {\n        counter += 1;\n        emit Counter(counter);\n        d.f();\n    }\n}\n",
    "recommendation": "Apply the [`check-effects-interactions` pattern](https://docs.soliditylang.org/en/latest/security-considerations.html#re-entrancy).",
    "explanation": "\n\nIf the external call `d.f()` re-enters `BugReentrancyEvents`, the `Counter` events will be incorrect (`Counter(2)`, `Counter(2)`) whereas `NoReentrancyEvents` will correctly emit \n(`Counter(1)`, `Counter(2)`). This may cause issues for offchain components that rely on the values of events e.g. checking for the amount deposited to a bridge."
  },
  "return-bomb": {
    "name": "Return Bomb",
    "check": "return-bomb",
    "description": "A low level callee may consume all callers gas unexpectedly.",
    "exploit": "//Modified from https://github.com/nomad-xyz/ExcessivelySafeCall\ncontract BadGuy {\n    function youveActivateMyTrapCard() external pure returns (bytes memory) {\n        assembly{\n            revert(0, 1000000)\n        }\n    }\n}\n\ncontract Mark {\n    function oops(address badGuy) public{\n        bool success;\n        bytes memory ret;\n\n        // Mark pays a lot of gas for this copy\n        //(success, ret) = badGuy.call{gas:10000}(\n        (success, ret) = badGuy.call(\n            abi.encodeWithSelector(\n                BadGuy.youveActivateMyTrapCard.selector\n            )\n        );\n\n        // Mark may OOG here, preventing local state changes\n        //importantCleanup();\n    }\n}\n\n",
    "recommendation": "Avoid unlimited implicit decoding of returndata.",
    "explanation": "\nAfter Mark calls BadGuy bytes are copied from returndata to memory, the memory expansion cost is paid. This means that when using a standard solidity call, the callee can \"returnbomb\" the caller, imposing an arbitrary gas cost. \nCallee unexpectedly makes the caller OOG."
  },
  "timestamp": {
    "name": "Block timestamp",
    "check": "timestamp",
    "description": "Dangerous usage of `block.timestamp`. `block.timestamp` can be manipulated by miners.",
    "exploit": "\"Bob's contract relies on `block.timestamp` for its randomness. Eve is a miner and manipulates `block.timestamp` to exploit Bob's contract.",
    "recommendation": "Avoid relying on `block.timestamp`."
  },
  "assembly": {
    "name": "Assembly usage",
    "check": "assembly",
    "description": "The use of assembly is error-prone and should be avoided.",
    "exploit": "",
    "recommendation": "Do not use `evm` assembly."
  },
  "assert-state-change": {
    "name": "Assert state change",
    "check": "assert-state-change",
    "description": "Incorrect use of `assert()`. See Solidity best [practices](https://solidity.readthedocs.io/en/latest/control-structures.html#id4).",
    "exploit": "contract A {\n\n  uint s_a;\n\n  function bad() public {\n    assert((s_a += 1) > 10);\n  }\n}\n",
    "recommendation": "Use `require` for invariants modifying the state.",
    "explanation": "\nThe assert in `bad()` increments the state variable `s_a` while checking for the condition."
  },
  "boolean-equal": {
    "name": "Boolean equality",
    "check": "boolean-equal",
    "description": "Detects the comparison to boolean constants.",
    "exploit": "contract A {\n\tfunction f(bool x) public {\n\t\t// ...\n        if (x == true) { // bad!\n           // ...\n        }\n\t\t// ...\n\t}\n}\n",
    "recommendation": "Remove the equality to the boolean constant.",
    "explanation": "\nBoolean constants can be used directly and do not need to be compare to `true` or `false`."
  },
  "cyclomatic-complexity": {
    "name": "Cyclomatic complexity",
    "check": "cyclomatic-complexity",
    "description": "Detects functions with high (> 11) cyclomatic complexity.",
    "exploit": "",
    "recommendation": "Reduce cyclomatic complexity by splitting the function into several smaller subroutines."
  },
  "deprecated-standards": {
    "name": "Deprecated standards",
    "check": "deprecated-standards",
    "description": "Detect the usage of deprecated standards.",
    "exploit": "contract ContractWithDeprecatedReferences {\n    // Deprecated: Change block.blockhash() -> blockhash()\n    bytes32 globalBlockHash = block.blockhash(0);\n\n    // Deprecated: Change constant -> view\n    function functionWithDeprecatedThrow() public constant {\n        // Deprecated: Change msg.gas -> gasleft()\n        if(msg.gas == msg.value) {\n            // Deprecated: Change throw -> revert()\n            throw;\n        }\n    }\n\n    // Deprecated: Change constant -> view\n    function functionWithDeprecatedReferences() public constant {\n        // Deprecated: Change sha3() -> keccak256()\n        bytes32 sha3Result = sha3(\"test deprecated sha3 usage\");\n\n        // Deprecated: Change callcode() -> delegatecall()\n        address(this).callcode();\n\n        // Deprecated: Change suicide() -> selfdestruct()\n        suicide(address(0));\n    }\n}\n",
    "recommendation": "Replace all uses of deprecated symbols.",
    "explanation": ""
  },
  "erc20-indexed": {
    "name": "Unindexed ERC20 event parameters",
    "check": "erc20-indexed",
    "description": "Detects whether events defined by the `ERC20` specification that should have some parameters as `indexed` are missing the `indexed` keyword.",
    "exploit": "contract ERC20Bad {\n    // ...\n    event Transfer(address from, address to, uint value);\n    event Approval(address owner, address spender, uint value);\n\n    // ...\n}\n",
    "recommendation": "Add the `indexed` keyword to event parameters that should include it, according to the `ERC20` specification.",
    "explanation": "\n`Transfer` and `Approval` events should have the 'indexed' keyword on their two first parameters, as defined by the `ERC20` specification.\nFailure to include these keywords will exclude the parameter data in the transaction/block's bloom filter, so external tooling searching for these parameters may overlook them and fail to index logs from this token contract."
  },
  "function-init-state": {
    "name": "Function Initializing State",
    "check": "function-init-state",
    "description": "Detects the immediate initialization of state variables through function calls that are not pure/constant, or that use non-constant state variable.",
    "exploit": "contract StateVarInitFromFunction {\n\n    uint public v = set(); // Initialize from function (sets to 77)\n    uint public w = 5;\n    uint public x = set(); // Initialize from function (sets to 88)\n    address public shouldntBeReported = address(8);\n\n    constructor(){\n        // The constructor is run after all state variables are initialized.\n    }\n\n    function set() public  returns(uint)  {\n        // If this function is being used to initialize a state variable declared\n        // before w, w will be zero. If it is declared after w, w will be set.\n        if(w == 0) {\n            return 77;\n        }\n\n        return 88;\n    }\n}\n",
    "recommendation": "Remove any initialization of state variables via non-constant state variables or function calls. If variables must be set upon contract deployment, locate initialization in the constructor instead.",
    "explanation": "\nIn this case, users might intend a function to return a value a state variable can initialize with, without realizing the context for the contract is not fully initialized. \nIn the example above, the same function sets two different values for state variables because it checks a state variable that is not yet initialized in one case, and is initialized in the other. \nSpecial care must be taken when initializing state variables from an immediate function call so as not to incorrectly assume the state is initialized."
  },
  "incorrect-using-for": {
    "name": "Incorrect usage of using-for statement",
    "check": "incorrect-using-for",
    "description": "In Solidity, it is possible to use libraries for certain types, by the `using-for` statement (`using <library> for <type>`). However, the Solidity compiler doesn't check whether a given library has at least one function matching a given type. If it doesn't, such a statement has no effect and may be confusing.",
    "exploit": "    library L {\n        function f(bool) public pure {}\n    }\n    \n    using L for uint;\n    ",
    "recommendation": "Make sure that the libraries used in `using-for` statements have at least one function matching a type used in these statements.",
    "explanation": "\n    Such a code will compile despite the fact that `L` has no function with `uint` as its first argument."
  },
  "low-level-calls": {
    "name": "Low-level calls",
    "check": "low-level-calls",
    "description": "The use of low-level calls is error-prone. Low-level calls do not check for [code existence](https://solidity.readthedocs.io/en/v0.4.25/control-structures.html#error-handling-assert-require-revert-and-exceptions) or call success.",
    "exploit": "",
    "recommendation": "Avoid low-level calls. Check the call success. If the call is meant for a contract, check for code existence."
  },
  "missing-inheritance": {
    "name": "Missing inheritance",
    "check": "missing-inheritance",
    "description": "Detect missing inheritance.",
    "exploit": "interface ISomething {\n    function f1() external returns(uint);\n}\n\ncontract Something {\n    function f1() external returns(uint){\n        return 42;\n    }\n}\n",
    "recommendation": "Inherit from the missing interface or contract.",
    "explanation": "\n`Something` should inherit from `ISomething`."
  },
  "naming-convention": {
    "name": "Conformance to Solidity naming conventions",
    "check": "naming-convention",
    "description": "Solidity defines a [naming convention](https://solidity.readthedocs.io/en/v0.4.25/style-guide.html#naming-conventions) that should be followed.",
    "exploit": "",
    "recommendation": "Follow the Solidity [naming convention](https://solidity.readthedocs.io/en/v0.4.25/style-guide.html#naming-conventions)."
  },
  "pragma": {
    "name": "Different pragma directives are used",
    "check": "pragma",
    "description": "Detect whether different Solidity versions are used.",
    "exploit": "",
    "recommendation": "Use one Solidity version."
  },
  "redundant-statements": {
    "name": "Redundant Statements",
    "check": "redundant-statements",
    "description": "Detect the usage of redundant statements that have no effect.",
    "exploit": "contract RedundantStatementsContract {\n\n    constructor() public {\n        uint; // Elementary Type Name\n        bool; // Elementary Type Name\n        RedundantStatementsContract; // Identifier\n    }\n\n    function test() public returns (uint) {\n        uint; // Elementary Type Name\n        assert; // Identifier\n        test; // Identifier\n        return 777;\n    }\n}\n",
    "recommendation": "Remove redundant statements if they congest code but offer no value.",
    "explanation": "\nEach commented line references types/identifiers, but performs no action with them, so no code will be generated for such statements and they can be removed."
  },
  "solc-version": {
    "name": "Incorrect versions of Solidity",
    "check": "solc-version",
    "description": "`solc` frequently releases new compiler versions. Using an old version prevents access to new Solidity security checks.\nWe also recommend avoiding complex `pragma` statement.",
    "exploit": "",
    "recommendation": "Deploy with any of the following Solidity versions:\n- 0.8.18\n\nThe recommendations take into account:\n- Risks related to recent releases\n- Risks of complex code generation changes\n- Risks of new language features\n- Risks of known bugs\n\nUse a simple pragma version that allows any of these versions.\nConsider using the latest version of Solidity for testing."
  },
  "unimplemented-functions": {
    "name": "Unimplemented functions",
    "check": "unimplemented-functions",
    "description": "Detect functions that are not implemented on derived-most contracts.",
    "exploit": "interface BaseInterface {\n    function f1() external returns(uint);\n    function f2() external returns(uint);\n}\n\ninterface BaseInterface2 {\n    function f3() external returns(uint);\n}\n\ncontract DerivedContract is BaseInterface, BaseInterface2 {\n    function f1() external returns(uint){\n        return 42;\n    }\n}\n",
    "recommendation": "Implement all unimplemented functions in any contract you intend to use directly (not simply inherit from).",
    "explanation": "\n`DerivedContract` does not implement `BaseInterface.f2` or `BaseInterface2.f3`.\nAs a result, the contract will not properly compile. \nAll unimplemented functions must be implemented on a contract that is meant to be used."
  },
  "unused-state": {
    "name": "Unused state variable",
    "check": "unused-state",
    "description": "Unused state variable.",
    "exploit": "",
    "recommendation": "Remove unused state variables."
  },
  "costly-loop": {
    "name": "Costly operations inside a loop",
    "check": "costly-loop",
    "description": "Costly operations inside a loop might waste gas, so optimizations are justified.",
    "exploit": "contract CostlyOperationsInLoop{\n\n    uint loop_count = 100;\n    uint state_variable=0;\n\n    function bad() external{\n        for (uint i=0; i < loop_count; i++){\n            state_variable++;\n        }\n    }\n\n    function good() external{\n      uint local_variable = state_variable;\n      for (uint i=0; i < loop_count; i++){\n        local_variable++;\n      }\n      state_variable = local_variable;\n    }\n}\n",
    "recommendation": "Use a local variable to hold the loop computation result.",
    "explanation": "\nIncrementing `state_variable` in a loop incurs a lot of gas because of expensive `SSTOREs`, which might lead to an `out-of-gas`."
  },
  "dead-code": {
    "name": "Dead-code",
    "check": "dead-code",
    "description": "Functions that are not sued.",
    "exploit": "contract Contract{\n    function dead_code() internal() {}\n}\n",
    "recommendation": "Remove unused functions.",
    "explanation": "\n`dead_code` is not used in the contract, and make the code's review more difficult."
  },
  "reentrancy-unlimited-gas": {
    "name": "Reentrancy vulnerabilities",
    "check": "reentrancy-unlimited-gas",
    "description": "Detection of the [reentrancy bug](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy).\nOnly report reentrancy that is based on `transfer` or `send`.",
    "exploit": "    function callme(){\n        msg.sender.transfer(balances[msg.sender]):\n        balances[msg.sender] = 0;\n    }   \n",
    "recommendation": "Apply the [`check-effects-interactions` pattern](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy).",
    "explanation": "\n\n`send` and `transfer` do not protect from reentrancies in case of gas price changes."
  },
  "similar-names": {
    "name": "Variable names too similar",
    "check": "similar-names",
    "description": "Detect variables with names that are too similar.",
    "exploit": "Bob uses several variables with similar names. As a result, his code is difficult to review.",
    "recommendation": "Prevent variables from having similar names."
  },
  "too-many-digits": {
    "name": "Too many digits",
    "check": "too-many-digits",
    "description": "Literals with many digits are difficult to read and review.",
    "exploit": "contract MyContract{\n    uint 1_ether = 10000000000000000000; \n}\n",
    "recommendation": "Use:\n- [Ether suffix](https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#ether-units),\n- [Time suffix](https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#time-units), or\n- [The scientific notation](https://solidity.readthedocs.io/en/latest/types.html#rational-and-integer-literals)",
    "explanation": "\n\nWhile `1_ether` looks like `1 ether`, it is `10 ether`. As a result, it's likely to be used incorrectly."
  },
  "cache-array-length": {
    "name": "Cache array length",
    "check": "cache-array-length",
    "description": "Detects `for` loops that use `length` member of some storage array in their loop condition and don't modify it.",
    "exploit": "contract C\n{\n    uint[] array;\n    \n    function f() public \n    {\n        for (uint i = 0; i < array.length; i++)\n        {\n            // code that does not modify length of `array`\n        }\n    }\n}\n",
    "recommendation": "Cache the lengths of storage arrays if they are used and not modified in `for` loops.",
    "explanation": "\nSince the `for` loop in `f` doesn't modify `array.length`, it is more gas efficient to cache it in some local variable and use that variable instead, like in the following example:\n\ncontract C\n{\n    uint[] array;\n    \n    function f() public \n    {\n        uint array_length = array.length;\n        for (uint i = 0; i < array_length; i++)\n        {\n            // code that does not modify length of `array`\n        }\n    }\n}\n"
  },
  "constable-states": {
    "name": "State variables that could be declared constant",
    "check": "constable-states",
    "description": "State variables that are not updated following deployment should be declared constant to save gas.",
    "exploit": "",
    "recommendation": "Add the `constant` attribute to state variables that never change."
  },
  "external-function": {
    "name": "Public function that could be declared external",
    "check": "external-function",
    "description": "`public` functions that are never called by the contract should be declared `external`, and its immutable parameters should be located in `calldata` to save gas.",
    "exploit": "",
    "recommendation": "Use the `external` attribute for functions never called from the contract, and change the location of immutable parameters to `calldata` to save gas."
  },
  "immutable-states": {
    "name": "State variables that could be declared immutable",
    "check": "immutable-states",
    "description": "State variables that are not updated following deployment should be declared immutable to save gas.",
    "exploit": "",
    "recommendation": "Add the `immutable` attribute to state variables that never change or are set only in the constructor."
  },
  "var-read-using-this": {
    "name": "Public variable read in external context",
    "check": "var-read-using-this",
    "description": "The contract reads its own variable using `this`, adding overhead of an unnecessary STATICCALL.",
    "exploit": "contract C {\n    mapping(uint => address) public myMap;\n    function test(uint x) external returns(address) {\n        return this.myMap(x);\n    }\n}\n",
    "recommendation": "Read the variable directly from storage instead of calling the contract.",
    "explanation": ""
  }
}