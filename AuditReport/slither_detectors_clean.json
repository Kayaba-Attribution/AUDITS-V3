{
  "Reentrancy vulnerabilities": {
    "numberOfDuplicates": 0,
    "findType": "function",
    "title": "Reentrancy in Prepe.swapBack() (contracts/AuditContract.sol#1284-1322):\n\tExternal calls:\n\t- swapTokensForEth(amountToSwapForETH) (contracts/AuditContract.sol#1301)\n\t\t- uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount,0,path,address(this),block.timestamp) (contracts/AuditContract.sol#1243-1249)\n\tState variables written after the call(s):\n\t- tokensForDev = 0 (contracts/AuditContract.sol#1312)\n\tPrepe.tokensForDev (contracts/AuditContract.sol#907) can be used in cross function reentrancies:\n\t- Prepe._transfer(address,address,uint256) (contracts/AuditContract.sol#1111-1231)\n\t- Prepe.swapBack() (contracts/AuditContract.sol#1284-1322)\n\t- Prepe.tokensForDev (contracts/AuditContract.sol#907)\n\t- tokensForLiquidity = 0 (contracts/AuditContract.sol#1310)\n\tPrepe.tokensForLiquidity (contracts/AuditContract.sol#906) can be used in cross function reentrancies:\n\t- Prepe._transfer(address,address,uint256) (contracts/AuditContract.sol#1111-1231)\n\t- Prepe.swapBack() (contracts/AuditContract.sol#1284-1322)\n\t- Prepe.tokensForLiquidity (contracts/AuditContract.sol#906)\n\t- tokensForMarketing = 0 (contracts/AuditContract.sol#1311)\n\tPrepe.tokensForMarketing (contracts/AuditContract.sol#905) can be used in cross function reentrancies:\n\t- Prepe._transfer(address,address,uint256) (contracts/AuditContract.sol#1111-1231)\n\t- Prepe.swapBack() (contracts/AuditContract.sol#1284-1322)\n\t- Prepe.tokensForMarketing (contracts/AuditContract.sol#905)\n",
    "check": "reentrancy-no-eth",
    "impact": "Medium",
    "confidence": "Medium",
    "sourceTest": "function swapBack() private {\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        uint256 totalTokensToSwap = tokensForLiquidity + tokensForMarketing + tokensForDev;\r\n        bool success;\r\n \r\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\r\n \r\n        if(contractBalance > swapTokensAtAmount * 20){\r\n          contractBalance = swapTokensAtAmount * 20;\r\n        }\r\n \r\n        // Halve the amount of liquidity tokens\r\n        uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;\r\n        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\r\n \r\n        uint256 initialETHBalance = address(this).balance;\r\n \r\n        swapTokensForEth(amountToSwapForETH); \r\n \r\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\r\n \r\n        uint256 ethForMarketing = ethBalance.mul(tokensForMarketing).div(totalTokensToSwap);\r\n        uint256 ethForDev = ethBalance.mul(tokensForDev).div(totalTokensToSwap);\r\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForDev;\r\n \r\n \r\n        tokensForLiquidity = 0;\r\n        tokensForMarketing = 0;\r\n        tokensForDev = 0;\r\n \r\n        (success,) = address(devWallet).call{value: ethForDev}(\"\");\r\n \r\n        if(liquidityTokens > 0 && ethForLiquidity > 0){\r\n            addLiquidity(liquidityTokens, ethForLiquidity);\r\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, tokensForLiquidity);\r\n        }\r\n \r\n        (success,) = address(marketingWallet).call{value: address(this).balance}(\"\");\r\n    }",
    "lines": [
      1284,
      1285,
      1286,
      1287,
      1288,
      1289,
      1290,
      1291,
      1292,
      1293,
      1294,
      1295,
      1296,
      1297,
      1298,
      1299,
      1300,
      1301,
      1302,
      1303,
      1304,
      1305,
      1306,
      1307,
      1308,
      1309,
      1310,
      1311,
      1312,
      1313,
      1314,
      1315,
      1316,
      1317,
      1318,
      1319,
      1320,
      1321,
      1322
    ],
    "name": "Reentrancy vulnerabilities",
    "exploit": "    function bug(){\n        require(not_called);\n        if( ! (msg.sender.call() ) ){\n            throw;\n        }\n        not_called = False;\n    }   \n",
    "description": "Detection of the [reentrancy bug](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy).\nDo not report reentrancies that involve Ether (see `reentrancy-eth`).",
    "recommendation": "Apply the [`check-effects-interactions` pattern](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy).",
    "explanation": ""
  },
  "Dangerous usage of `tx.origin`": {
    "numberOfDuplicates": 0,
    "findType": "function",
    "title": "Prepe._transfer(address,address,uint256) (contracts/AuditContract.sol#1111-1231) uses tx.origin for authorization: require(bool,string)(_holderLastTransferTimestamp[tx.origin] < block.number,_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.) (contracts/AuditContract.sol#1139)\n",
    "check": "tx-origin",
    "impact": "Medium",
    "confidence": "Medium",
    "sourceTest": "function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(!_blacklist[to] && !_blacklist[from], \"You have been blacklisted from transfering tokens\");\r\n         if(amount == 0) {\r\n            super._transfer(from, to, 0);\r\n            return;\r\n        }\r\n \r\n        if(limitsInEffect){\r\n            if (\r\n                from != owner() &&\r\n                to != owner() &&\r\n                to != address(0) &&\r\n                to != address(0xdead) &&\r\n                !swapping\r\n            ){\r\n                if(!tradingActive){\r\n                    require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \"Trading is not active.\");\r\n                }\r\n \r\n                // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.  \r\n                if (transferDelayEnabled){\r\n                    if (to != owner() && to != address(uniswapV2Router) && to != address(uniswapV2Pair)){\r\n                        require(_holderLastTransferTimestamp[tx.origin] < block.number, \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\r\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\r\n                    }\r\n                }\r\n \r\n                //when buy\r\n                    if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\r\n                        require(amount <= maxTransactionAmount, \"Buy transfer amount exceeds the maxTransactionAmount.\");\r\n                        require(balanceOf(to) + amount <= maxWallet, \"Max wallet exceeded\");\r\n                    }\r\n                    else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\r\n                        require(amount <= maxTransactionAmount, \"Sell transfer amount exceeds the maxTransactionAmount.\");\r\n                        require(balanceOf(from) - amount >= 0, \"Insufficient balance\");\r\n                        require(balanceOf(to) + amount <= maxWallet, \"Max wallet exceeded\");\r\n                    }\r\n                    else if (!_isExcludedMaxTransactionAmount[to]) {\r\n                        require(balanceOf(to) + amount <= maxWallet, \"Max wallet exceeded\");\r\n                    }\r\n            }\r\n        }\r\n \r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n \r\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\r\n \r\n        if( \r\n            canSwap &&\r\n            swapEnabled &&\r\n            !swapping &&\r\n            !automatedMarketMakerPairs[from] &&\r\n            !_isExcludedFromFees[from] &&\r\n            !_isExcludedFromFees[to]\r\n        ) {\r\n            swapping = true;\r\n \r\n            swapBack();\r\n \r\n            swapping = false;\r\n        }\r\n \r\n        bool takeFee = !swapping;\r\n \r\n        // if any account belongs to _isExcludedFromFee account then remove the fee\r\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\r\n            takeFee = false;\r\n        }\r\n \r\n      \r\n        // only take fees on buys/sells, do not take on wallet transfers\r\n     if (takeFee) {\r\n        uint256 calculatedFees;\r\n        uint256 liquidityFee;\r\n        uint256 devFee;\r\n        uint256 marketingFee;\r\n\r\n       if (automatedMarketMakerPairs[to]) { // On sell\r\n            if (_isWhitelisted[from]) {\r\n                calculatedFees = amount.mul(10).div(100);\r\n                liquidityFee = 0;\r\n                devFee = 5;\r\n                marketingFee = 5;\r\n            } else {\r\n                calculatedFees = amount.mul(sellTotalFees).div(100);\r\n                liquidityFee = sellLiquidityFee;\r\n                devFee = sellDevFee;\r\n                marketingFee = sellMarketingFee;\r\n            }\r\n        } else if (automatedMarketMakerPairs[from]) { // On buy\r\n            if (_isWhitelisted[to]) {\r\n                calculatedFees = 0;\r\n                liquidityFee = 0;\r\n                devFee = 0;\r\n                marketingFee = 0;\r\n            } else {\r\n                calculatedFees = amount.mul(buyTotalFees).div(100);\r\n                liquidityFee = buyLiquidityFee;\r\n                devFee = buyDevFee;\r\n                marketingFee = buyMarketingFee;\r\n            }\r\n        }\r\n        if (calculatedFees > 0) {\r\n            uint256 totalFee = liquidityFee + devFee + marketingFee;\r\n            tokensForLiquidity += calculatedFees.mul(liquidityFee).div(totalFee);\r\n            tokensForDev += calculatedFees.mul(devFee).div(totalFee);\r\n            tokensForMarketing += calculatedFees.mul(marketingFee).div(totalFee);\r\n            super._transfer(from, address(this), calculatedFees);\r\n            amount -= calculatedFees;\r\n        }\r\n    }\r\n\r\n \r\n        super._transfer(from, to, amount);\r\n    }",
    "lines": [
      1111,
      1112,
      1113,
      1114,
      1115,
      1116,
      1117,
      1118,
      1119,
      1120,
      1121,
      1122,
      1123,
      1124,
      1125,
      1126,
      1127,
      1128,
      1129,
      1130,
      1131,
      1132,
      1133,
      1134,
      1135,
      1136,
      1137,
      1138,
      1139,
      1140,
      1141,
      1142,
      1143,
      1144,
      1145,
      1146,
      1147,
      1148,
      1149,
      1150,
      1151,
      1152,
      1153,
      1154,
      1155,
      1156,
      1157,
      1158,
      1159,
      1160,
      1161,
      1162,
      1163,
      1164,
      1165,
      1166,
      1167,
      1168,
      1169,
      1170,
      1171,
      1172,
      1173,
      1174,
      1175,
      1176,
      1177,
      1178,
      1179,
      1180,
      1181,
      1182,
      1183,
      1184,
      1185,
      1186,
      1187,
      1188,
      1189,
      1190,
      1191,
      1192,
      1193,
      1194,
      1195,
      1196,
      1197,
      1198,
      1199,
      1200,
      1201,
      1202,
      1203,
      1204,
      1205,
      1206,
      1207,
      1208,
      1209,
      1210,
      1211,
      1212,
      1213,
      1214,
      1215,
      1216,
      1217,
      1218,
      1219,
      1220,
      1221,
      1222,
      1223,
      1224,
      1225,
      1226,
      1227,
      1228,
      1229,
      1230,
      1231
    ],
    "name": "Dangerous usage of `tx.origin`",
    "exploit": "contract TxOrigin {\n    address owner = msg.sender;\n\n    function bug() {\n        require(tx.origin == owner);\n    }\n",
    "description": "`tx.origin`-based protection can be abused by a malicious contract if a legitimate user interacts with the malicious contract.",
    "recommendation": "Do not use `tx.origin` for authorization.",
    "explanation": "\nBob is the owner of `TxOrigin`. Bob calls Eve's contract. Eve's contract calls `TxOrigin` and bypasses the `tx.origin` protection."
  },
  "Tautology or contradiction": {
    "numberOfDuplicates": 0,
    "findType": "function",
    "title": "Prepe._transfer(address,address,uint256) (contracts/AuditContract.sol#1111-1231) contains a tautology or contradiction:\n\t- require(bool,string)(balanceOf(from) - amount >= 0,Insufficient balance) (contracts/AuditContract.sol#1151)\n",
    "check": "tautology",
    "impact": "Medium",
    "confidence": "High",
    "sourceTest": "function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(!_blacklist[to] && !_blacklist[from], \"You have been blacklisted from transfering tokens\");\r\n         if(amount == 0) {\r\n            super._transfer(from, to, 0);\r\n            return;\r\n        }\r\n \r\n        if(limitsInEffect){\r\n            if (\r\n                from != owner() &&\r\n                to != owner() &&\r\n                to != address(0) &&\r\n                to != address(0xdead) &&\r\n                !swapping\r\n            ){\r\n                if(!tradingActive){\r\n                    require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \"Trading is not active.\");\r\n                }\r\n \r\n                // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.  \r\n                if (transferDelayEnabled){\r\n                    if (to != owner() && to != address(uniswapV2Router) && to != address(uniswapV2Pair)){\r\n                        require(_holderLastTransferTimestamp[tx.origin] < block.number, \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\r\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\r\n                    }\r\n                }\r\n \r\n                //when buy\r\n                    if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\r\n                        require(amount <= maxTransactionAmount, \"Buy transfer amount exceeds the maxTransactionAmount.\");\r\n                        require(balanceOf(to) + amount <= maxWallet, \"Max wallet exceeded\");\r\n                    }\r\n                    else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\r\n                        require(amount <= maxTransactionAmount, \"Sell transfer amount exceeds the maxTransactionAmount.\");\r\n                        require(balanceOf(from) - amount >= 0, \"Insufficient balance\");\r\n                        require(balanceOf(to) + amount <= maxWallet, \"Max wallet exceeded\");\r\n                    }\r\n                    else if (!_isExcludedMaxTransactionAmount[to]) {\r\n                        require(balanceOf(to) + amount <= maxWallet, \"Max wallet exceeded\");\r\n                    }\r\n            }\r\n        }\r\n \r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n \r\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\r\n \r\n        if( \r\n            canSwap &&\r\n            swapEnabled &&\r\n            !swapping &&\r\n            !automatedMarketMakerPairs[from] &&\r\n            !_isExcludedFromFees[from] &&\r\n            !_isExcludedFromFees[to]\r\n        ) {\r\n            swapping = true;\r\n \r\n            swapBack();\r\n \r\n            swapping = false;\r\n        }\r\n \r\n        bool takeFee = !swapping;\r\n \r\n        // if any account belongs to _isExcludedFromFee account then remove the fee\r\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\r\n            takeFee = false;\r\n        }\r\n \r\n      \r\n        // only take fees on buys/sells, do not take on wallet transfers\r\n     if (takeFee) {\r\n        uint256 calculatedFees;\r\n        uint256 liquidityFee;\r\n        uint256 devFee;\r\n        uint256 marketingFee;\r\n\r\n       if (automatedMarketMakerPairs[to]) { // On sell\r\n            if (_isWhitelisted[from]) {\r\n                calculatedFees = amount.mul(10).div(100);\r\n                liquidityFee = 0;\r\n                devFee = 5;\r\n                marketingFee = 5;\r\n            } else {\r\n                calculatedFees = amount.mul(sellTotalFees).div(100);\r\n                liquidityFee = sellLiquidityFee;\r\n                devFee = sellDevFee;\r\n                marketingFee = sellMarketingFee;\r\n            }\r\n        } else if (automatedMarketMakerPairs[from]) { // On buy\r\n            if (_isWhitelisted[to]) {\r\n                calculatedFees = 0;\r\n                liquidityFee = 0;\r\n                devFee = 0;\r\n                marketingFee = 0;\r\n            } else {\r\n                calculatedFees = amount.mul(buyTotalFees).div(100);\r\n                liquidityFee = buyLiquidityFee;\r\n                devFee = buyDevFee;\r\n                marketingFee = buyMarketingFee;\r\n            }\r\n        }\r\n        if (calculatedFees > 0) {\r\n            uint256 totalFee = liquidityFee + devFee + marketingFee;\r\n            tokensForLiquidity += calculatedFees.mul(liquidityFee).div(totalFee);\r\n            tokensForDev += calculatedFees.mul(devFee).div(totalFee);\r\n            tokensForMarketing += calculatedFees.mul(marketingFee).div(totalFee);\r\n            super._transfer(from, address(this), calculatedFees);\r\n            amount -= calculatedFees;\r\n        }\r\n    }\r\n\r\n \r\n        super._transfer(from, to, amount);\r\n    }",
    "lines": [
      1111,
      1112,
      1113,
      1114,
      1115,
      1116,
      1117,
      1118,
      1119,
      1120,
      1121,
      1122,
      1123,
      1124,
      1125,
      1126,
      1127,
      1128,
      1129,
      1130,
      1131,
      1132,
      1133,
      1134,
      1135,
      1136,
      1137,
      1138,
      1139,
      1140,
      1141,
      1142,
      1143,
      1144,
      1145,
      1146,
      1147,
      1148,
      1149,
      1150,
      1151,
      1152,
      1153,
      1154,
      1155,
      1156,
      1157,
      1158,
      1159,
      1160,
      1161,
      1162,
      1163,
      1164,
      1165,
      1166,
      1167,
      1168,
      1169,
      1170,
      1171,
      1172,
      1173,
      1174,
      1175,
      1176,
      1177,
      1178,
      1179,
      1180,
      1181,
      1182,
      1183,
      1184,
      1185,
      1186,
      1187,
      1188,
      1189,
      1190,
      1191,
      1192,
      1193,
      1194,
      1195,
      1196,
      1197,
      1198,
      1199,
      1200,
      1201,
      1202,
      1203,
      1204,
      1205,
      1206,
      1207,
      1208,
      1209,
      1210,
      1211,
      1212,
      1213,
      1214,
      1215,
      1216,
      1217,
      1218,
      1219,
      1220,
      1221,
      1222,
      1223,
      1224,
      1225,
      1226,
      1227,
      1228,
      1229,
      1230,
      1231
    ],
    "name": "Tautology or contradiction",
    "exploit": "contract A {\n\tfunction f(uint x) public {\n\t\t// ...\n        if (x >= 0) { // bad -- always true\n           // ...\n        }\n\t\t// ...\n\t}\n\n\tfunction g(uint8 y) public returns (bool) {\n\t\t// ...\n        return (y < 512); // bad!\n\t\t// ...\n\t}\n}\n",
    "description": "Detects expressions that are tautologies or contradictions.",
    "recommendation": "Fix the incorrect comparison by changing the value type or the comparison.",
    "explanation": "\n`x` is a `uint256`, so `x >= 0` will be always true.\n`y` is a `uint8`, so `y <512` will be always true."
  },
  "Uninitialized local variables": {
    "numberOfDuplicates": 3,
    "findType": "variable",
    "title": "Prepe._transfer(address,address,uint256).marketingFee (contracts/AuditContract.sol#1192) is a local variable never initialized\n\nPrepe._transfer(address,address,uint256).devFee (contracts/AuditContract.sol#1191) is a local variable never initialized\n\nPrepe._transfer(address,address,uint256).liquidityFee (contracts/AuditContract.sol#1190) is a local variable never initialized\n\nPrepe._transfer(address,address,uint256).calculatedFees (contracts/AuditContract.sol#1189) is a local variable never initialized\n",
    "check": "uninitialized-local",
    "impact": "Medium",
    "confidence": "Medium",
    "sourceTest": "uint256 marketingFee;\nuint256 devFee;\nuint256 liquidityFee;\nuint256 calculatedFees;",
    "lines": [
      1192,
      1191,
      1190,
      1189
    ],
    "name": "Uninitialized local variables",
    "exploit": "contract Uninitialized is Owner{\n    function withdraw() payable public onlyOwner{\n        address to;\n        to.transfer(this.balance)\n    }\n}\n",
    "description": "Uninitialized local variables.",
    "recommendation": "Initialize all the variables. If a variable is meant to be initialized to zero, explicitly set it to zero to improve code readability.",
    "explanation": "\nBob calls `transfer`. As a result, all Ether is sent to the address `0x0` and is lost."
  },
  "Unused return": {
    "numberOfDuplicates": 0,
    "findType": "function",
    "title": "Prepe.addLiquidity(uint256,uint256) (contracts/AuditContract.sol#1269-1282) ignores return value by uniswapV2Router.addLiquidityETH{value: ethAmount}(address(this),tokenAmount,0,0,address(this),block.timestamp) (contracts/AuditContract.sol#1274-1281)\n",
    "check": "unused-return",
    "impact": "Medium",
    "confidence": "Medium",
    "sourceTest": "function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\r\n        // approve token transfer to cover all possible scenarios\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n \r\n        // add the liquidity\r\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0, // slippage is unavoidable\r\n            0, // slippage is unavoidable\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }",
    "lines": [
      1269,
      1270,
      1271,
      1272,
      1273,
      1274,
      1275,
      1276,
      1277,
      1278,
      1279,
      1280,
      1281,
      1282
    ],
    "name": "Unused return",
    "exploit": "contract MyConc{\n    using SafeMath for uint;   \n    function my_func(uint a, uint b) public{\n        a.add(b);\n    }\n}\n",
    "description": "The return value of an external call is not stored in a local or state variable.",
    "recommendation": "Ensure that all the return values of the function calls are used.",
    "explanation": "\n`MyConc` calls `add` of `SafeMath`, but does not store the result in `a`. As a result, the computation has no effect."
  },
  "Local variable shadowing": {
    "numberOfDuplicates": 1,
    "findType": "variable",
    "title": "Prepe.constructor().totalSupply (contracts/AuditContract.sol#964) shadows:\n\t- ERC20.totalSupply() (contracts/AuditContract.sol#245-247) (function)\n\t- IERC20.totalSupply() (contracts/AuditContract.sol#95) (function)\n\nPrepe.ApproveAccount(address,bool).isBlacklisted (contracts/AuditContract.sol#1080) shadows:\n\t- Prepe.isBlacklisted(address) (contracts/AuditContract.sol#1361-1363) (function)\n",
    "check": "shadowing-local",
    "impact": "Low",
    "confidence": "High",
    "sourceTest": "uint256 totalSupply = 420690000000000000000000000000000;\nfunction ApproveAccount (address account, bool isBlacklisted) public onlyOwner {",
    "lines": [
      964,
      1080
    ],
    "name": "Local variable shadowing",
    "exploit": "pragma solidity ^0.4.24;\n\ncontract Bug {\n    uint owner;\n\n    function sensitive_function(address owner) public {\n        // ...\n        require(owner == msg.sender);\n    }\n\n    function alternate_sensitive_function() public {\n        address owner = msg.sender;\n        // ...\n        require(owner == msg.sender);\n    }\n}\n",
    "description": "Detection of shadowing using local variables.",
    "recommendation": "Rename the local variables that shadow another component.",
    "explanation": "\n`sensitive_function.owner` shadows `Bug.owner`. As a result, the use of `owner` in `sensitive_function` might be incorrect."
  },
  "Missing events arithmetic": {
    "numberOfDuplicates": 4,
    "findType": "function",
    "title": "Prepe.updateMaxWalletAmount(uint256) (contracts/AuditContract.sol#1036-1039) should emit an event for: \n\t- maxWallet = newNum * (10 ** 18) (contracts/AuditContract.sol#1038) \n\nPrepe.updateMaxTxnAmount(uint256) (contracts/AuditContract.sol#1031-1034) should emit an event for: \n\t- maxTransactionAmount = newNum * (10 ** 18) (contracts/AuditContract.sol#1033) \n\nPrepe.updateBuyFees(uint256,uint256,uint256) (contracts/AuditContract.sol#1046-1056) should emit an event for: \n\t- buyDevFee = _devFee (contracts/AuditContract.sol#1051) \n\t- buyLiquidityFee = _liquidityFee (contracts/AuditContract.sol#1052) \n\t- buyMarketingFee = _marketingFee (contracts/AuditContract.sol#1053) \n\t- buyTotalFees = buyDevFee + buyLiquidityFee + buyMarketingFee (contracts/AuditContract.sol#1054) \n\nPrepe.updateSwapTokensAtAmount(uint256) (contracts/AuditContract.sol#1024-1029) should emit an event for: \n\t- swapTokensAtAmount = newAmount (contracts/AuditContract.sol#1027) \n\nPrepe.updateSellFees(uint256,uint256,uint256) (contracts/AuditContract.sol#1058-1068) should emit an event for: \n\t- sellDevFee = _devFee (contracts/AuditContract.sol#1063) \n\t- sellLiquidityFee = _liquidityFee (contracts/AuditContract.sol#1064) \n\t- sellMarketingFee = _marketingFee (contracts/AuditContract.sol#1065) \n\t- sellTotalFees = sellDevFee + sellLiquidityFee + sellMarketingFee (contracts/AuditContract.sol#1066) \n",
    "check": "events-maths",
    "impact": "Low",
    "confidence": "Medium",
    "sourceTest": "function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\r\n        require(newNum >= (totalSupply() * 5 / 1000), \"Cannot set maxWallet lower than 0.5%\");\r\n        maxWallet = newNum * (10**18);\r\n    }\nfunction updateMaxTxnAmount(uint256 newNum) external onlyOwner {\r\n        require(newNum >= (totalSupply() * 1 / 1000)/1e18, \"Cannot set maxTransactionAmount lower than 0.1%\");\r\n        maxTransactionAmount = newNum * (10**18);\r\n    }\nfunction updateBuyFees(\r\n        uint256 _devFee,\r\n        uint256 _liquidityFee,\r\n        uint256 _marketingFee\r\n    ) external onlyOwner {\r\n        buyDevFee = _devFee;\r\n        buyLiquidityFee = _liquidityFee;\r\n        buyMarketingFee = _marketingFee;\r\n        buyTotalFees = buyDevFee + buyLiquidityFee + buyMarketingFee;\r\n        require(buyTotalFees <= 100);\r\n    }\nfunction updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner returns (bool){\r\n        require(newAmount >= totalSupply() * 1 / 100000, \"Swap amount cannot be lower than 0.001% total supply.\");\r\n        require(newAmount <= totalSupply() * 5 / 1000, \"Swap amount cannot be higher than 0.5% total supply.\");\r\n        swapTokensAtAmount = newAmount;\r\n        return true;\r\n    }\nfunction updateSellFees(\r\n        uint256 _devFee,\r\n        uint256 _liquidityFee,\r\n        uint256 _marketingFee\r\n    ) external onlyOwner {\r\n        sellDevFee = _devFee;\r\n        sellLiquidityFee = _liquidityFee;\r\n        sellMarketingFee = _marketingFee;\r\n        sellTotalFees = sellDevFee + sellLiquidityFee + sellMarketingFee;\r\n        require(sellTotalFees <= 100);\r\n    }",
    "lines": [
      1036,
      1037,
      1038,
      1039,
      1031,
      1032,
      1033,
      1034,
      1046,
      1047,
      1048,
      1049,
      1050,
      1051,
      1052,
      1053,
      1054,
      1055,
      1056,
      1024,
      1025,
      1026,
      1027,
      1028,
      1029,
      1058,
      1059,
      1060,
      1061,
      1062,
      1063,
      1064,
      1065,
      1066,
      1067,
      1068
    ],
    "name": "Missing events arithmetic",
    "exploit": "contract C {\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _;\n    }\n\n    function setBuyPrice(uint256 newBuyPrice) onlyOwner public {\n        buyPrice = newBuyPrice;\n    }\n\n    function buy() external {\n     ... // buyPrice is used to determine the number of tokens purchased\n    }    \n}\n",
    "description": "Detect missing events for critical arithmetic parameters.",
    "recommendation": "Emit an event for critical parameter changes.",
    "explanation": "\n`setBuyPrice()` does not emit an event, so it is difficult to track changes in the value of `buyPrice` off-chain."
  },
  "Missing zero address validation": {
    "numberOfDuplicates": 1,
    "findType": "variable",
    "title": "Prepe.updateDevWallet(address).newWallet (contracts/AuditContract.sol#1101) lacks a zero-check on :\n\t\t- devWallet = newWallet (contracts/AuditContract.sol#1103)\n\nPrepe.updateMarketingWallet(address).newMarketingWallet (contracts/AuditContract.sol#1096) lacks a zero-check on :\n\t\t- marketingWallet = newMarketingWallet (contracts/AuditContract.sol#1098)\n",
    "check": "missing-zero-check",
    "impact": "Low",
    "confidence": "Medium",
    "sourceTest": "function updateDevWallet(address newWallet) external onlyOwner {\nfunction updateMarketingWallet(address newMarketingWallet) external onlyOwner {",
    "lines": [
      1101,
      1096
    ],
    "name": "Missing zero address validation",
    "exploit": "contract C {\n\n  modifier onlyAdmin {\n    if (msg.sender != owner) throw;\n    _;\n  }\n\n  function updateOwner(address newOwner) onlyAdmin external {\n    owner = newOwner;\n  }\n}\n",
    "description": "Detect missing zero address validation.",
    "recommendation": "Check that the address is not zero.",
    "explanation": "\nBob calls `updateOwner` without specifying the `newOwner`, so Bob loses ownership of the contract."
  },
  "Block timestamp": {
    "numberOfDuplicates": 0,
    "findType": "function",
    "title": "Prepe.swapTokensForEth(uint256) (contracts/AuditContract.sol#1233-1259) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- block.timestamp >= contractCreationTime + SEVEN_DAYS (contracts/AuditContract.sol#1251)\n",
    "check": "timestamp",
    "impact": "Low",
    "confidence": "Medium",
    "sourceTest": "function swapTokensForEth(uint256 tokenAmount) private {\r\n \r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n \r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n \r\n        // make the swap\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n            if (block.timestamp >= contractCreationTime + SEVEN_DAYS) {\r\n            // Ensure _resetSellFees() is only executed once after 7 days have passed\r\n            if (!_sellFeesReset) {\r\n                _resetSellFees();\r\n                _sellFeesReset = true;\r\n            }\r\n}\r\n \r\n    }",
    "lines": [
      1233,
      1234,
      1235,
      1236,
      1237,
      1238,
      1239,
      1240,
      1241,
      1242,
      1243,
      1244,
      1245,
      1246,
      1247,
      1248,
      1249,
      1250,
      1251,
      1252,
      1253,
      1254,
      1255,
      1256,
      1257,
      1258,
      1259
    ],
    "name": "Block timestamp",
    "exploit": "\"Bob's contract relies on `block.timestamp` for its randomness. Eve is a miner and manipulates `block.timestamp` to exploit Bob's contract.",
    "description": "Dangerous usage of `block.timestamp`. `block.timestamp` can be manipulated by miners.",
    "recommendation": "Avoid relying on `block.timestamp`."
  },
  "Cyclomatic complexity": {
    "numberOfDuplicates": 0,
    "findType": "function",
    "title": "Prepe._transfer(address,address,uint256) (contracts/AuditContract.sol#1111-1231) has a high cyclomatic complexity (17).\n",
    "check": "cyclomatic-complexity",
    "impact": "Informational",
    "confidence": "High",
    "sourceTest": "function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(!_blacklist[to] && !_blacklist[from], \"You have been blacklisted from transfering tokens\");\r\n         if(amount == 0) {\r\n            super._transfer(from, to, 0);\r\n            return;\r\n        }\r\n \r\n        if(limitsInEffect){\r\n            if (\r\n                from != owner() &&\r\n                to != owner() &&\r\n                to != address(0) &&\r\n                to != address(0xdead) &&\r\n                !swapping\r\n            ){\r\n                if(!tradingActive){\r\n                    require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \"Trading is not active.\");\r\n                }\r\n \r\n                // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.  \r\n                if (transferDelayEnabled){\r\n                    if (to != owner() && to != address(uniswapV2Router) && to != address(uniswapV2Pair)){\r\n                        require(_holderLastTransferTimestamp[tx.origin] < block.number, \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\r\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\r\n                    }\r\n                }\r\n \r\n                //when buy\r\n                    if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\r\n                        require(amount <= maxTransactionAmount, \"Buy transfer amount exceeds the maxTransactionAmount.\");\r\n                        require(balanceOf(to) + amount <= maxWallet, \"Max wallet exceeded\");\r\n                    }\r\n                    else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\r\n                        require(amount <= maxTransactionAmount, \"Sell transfer amount exceeds the maxTransactionAmount.\");\r\n                        require(balanceOf(from) - amount >= 0, \"Insufficient balance\");\r\n                        require(balanceOf(to) + amount <= maxWallet, \"Max wallet exceeded\");\r\n                    }\r\n                    else if (!_isExcludedMaxTransactionAmount[to]) {\r\n                        require(balanceOf(to) + amount <= maxWallet, \"Max wallet exceeded\");\r\n                    }\r\n            }\r\n        }\r\n \r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n \r\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\r\n \r\n        if( \r\n            canSwap &&\r\n            swapEnabled &&\r\n            !swapping &&\r\n            !automatedMarketMakerPairs[from] &&\r\n            !_isExcludedFromFees[from] &&\r\n            !_isExcludedFromFees[to]\r\n        ) {\r\n            swapping = true;\r\n \r\n            swapBack();\r\n \r\n            swapping = false;\r\n        }\r\n \r\n        bool takeFee = !swapping;\r\n \r\n        // if any account belongs to _isExcludedFromFee account then remove the fee\r\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\r\n            takeFee = false;\r\n        }\r\n \r\n      \r\n        // only take fees on buys/sells, do not take on wallet transfers\r\n     if (takeFee) {\r\n        uint256 calculatedFees;\r\n        uint256 liquidityFee;\r\n        uint256 devFee;\r\n        uint256 marketingFee;\r\n\r\n       if (automatedMarketMakerPairs[to]) { // On sell\r\n            if (_isWhitelisted[from]) {\r\n                calculatedFees = amount.mul(10).div(100);\r\n                liquidityFee = 0;\r\n                devFee = 5;\r\n                marketingFee = 5;\r\n            } else {\r\n                calculatedFees = amount.mul(sellTotalFees).div(100);\r\n                liquidityFee = sellLiquidityFee;\r\n                devFee = sellDevFee;\r\n                marketingFee = sellMarketingFee;\r\n            }\r\n        } else if (automatedMarketMakerPairs[from]) { // On buy\r\n            if (_isWhitelisted[to]) {\r\n                calculatedFees = 0;\r\n                liquidityFee = 0;\r\n                devFee = 0;\r\n                marketingFee = 0;\r\n            } else {\r\n                calculatedFees = amount.mul(buyTotalFees).div(100);\r\n                liquidityFee = buyLiquidityFee;\r\n                devFee = buyDevFee;\r\n                marketingFee = buyMarketingFee;\r\n            }\r\n        }\r\n        if (calculatedFees > 0) {\r\n            uint256 totalFee = liquidityFee + devFee + marketingFee;\r\n            tokensForLiquidity += calculatedFees.mul(liquidityFee).div(totalFee);\r\n            tokensForDev += calculatedFees.mul(devFee).div(totalFee);\r\n            tokensForMarketing += calculatedFees.mul(marketingFee).div(totalFee);\r\n            super._transfer(from, address(this), calculatedFees);\r\n            amount -= calculatedFees;\r\n        }\r\n    }\r\n\r\n \r\n        super._transfer(from, to, amount);\r\n    }",
    "lines": [
      1111,
      1112,
      1113,
      1114,
      1115,
      1116,
      1117,
      1118,
      1119,
      1120,
      1121,
      1122,
      1123,
      1124,
      1125,
      1126,
      1127,
      1128,
      1129,
      1130,
      1131,
      1132,
      1133,
      1134,
      1135,
      1136,
      1137,
      1138,
      1139,
      1140,
      1141,
      1142,
      1143,
      1144,
      1145,
      1146,
      1147,
      1148,
      1149,
      1150,
      1151,
      1152,
      1153,
      1154,
      1155,
      1156,
      1157,
      1158,
      1159,
      1160,
      1161,
      1162,
      1163,
      1164,
      1165,
      1166,
      1167,
      1168,
      1169,
      1170,
      1171,
      1172,
      1173,
      1174,
      1175,
      1176,
      1177,
      1178,
      1179,
      1180,
      1181,
      1182,
      1183,
      1184,
      1185,
      1186,
      1187,
      1188,
      1189,
      1190,
      1191,
      1192,
      1193,
      1194,
      1195,
      1196,
      1197,
      1198,
      1199,
      1200,
      1201,
      1202,
      1203,
      1204,
      1205,
      1206,
      1207,
      1208,
      1209,
      1210,
      1211,
      1212,
      1213,
      1214,
      1215,
      1216,
      1217,
      1218,
      1219,
      1220,
      1221,
      1222,
      1223,
      1224,
      1225,
      1226,
      1227,
      1228,
      1229,
      1230,
      1231
    ],
    "name": "Cyclomatic complexity",
    "exploit": "",
    "description": "Detects functions with high (> 11) cyclomatic complexity.",
    "recommendation": "Reduce cyclomatic complexity by splitting the function into several smaller subroutines."
  },
  "Dead-code": {
    "numberOfDuplicates": 10,
    "findType": "function",
    "title": "SafeMathInt.div(int256,int256) (contracts/AuditContract.sol#678-684) is never used and should be removed\n\nSafeMathInt.abs(int256) (contracts/AuditContract.sol#707-710) is never used and should be removed\n\nSafeMathUint.toInt256Safe(uint256) (contracts/AuditContract.sol#720-724) is never used and should be removed\n\nSafeMathInt.mul(int256,int256) (contracts/AuditContract.sol#666-673) is never used and should be removed\n\nERC20._burn(address,uint256) (contracts/AuditContract.sol#406-414) is never used and should be removed\n\nSafeMath.mod(uint256,uint256,string) (contracts/AuditContract.sol#599-602) is never used and should be removed\n\nSafeMathInt.toUint256Safe(int256) (contracts/AuditContract.sol#713-716) is never used and should be removed\n\nSafeMathInt.sub(int256,int256) (contracts/AuditContract.sol#689-693) is never used and should be removed\n\nContext._msgData() (contracts/AuditContract.sol#19-22) is never used and should be removed\n\nSafeMath.mod(uint256,uint256) (contracts/AuditContract.sol#583-585) is never used and should be removed\n\nSafeMathInt.add(int256,int256) (contracts/AuditContract.sol#698-702) is never used and should be removed\n",
    "check": "dead-code",
    "impact": "Informational",
    "confidence": "Medium",
    "sourceTest": "function div(int256 a, int256 b) internal pure returns (int256) {\r\n        // Prevent overflow when dividing MIN_INT256 by -1\r\n        require(b != -1 || a != MIN_INT256);\r\n \r\n        // Solidity already throws when dividing by 0.\r\n        return a / b;\r\n    }\nfunction abs(int256 a) internal pure returns (int256) {\r\n        require(a != MIN_INT256);\r\n        return a < 0 ? -a : a;\r\n    }\nfunction toInt256Safe(uint256 a) internal pure returns (int256) {\r\n    int256 b = int256(a);\r\n    require(b >= 0);\r\n    return b;\r\n  }\nfunction mul(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a * b;\r\n \r\n        // Detect overflow when multiplying MIN_INT256 with -1\r\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\nfunction _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n \r\n        _beforeTokenTransfer(account, address(0), amount);\r\n \r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\nfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\nfunction toUint256Safe(int256 a) internal pure returns (uint256) {\r\n        require(a >= 0);\r\n        return uint256(a);\r\n    }\nfunction sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\nfunction _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\nfunction add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }",
    "lines": [
      678,
      679,
      680,
      681,
      682,
      683,
      684,
      707,
      708,
      709,
      710,
      720,
      721,
      722,
      723,
      724,
      666,
      667,
      668,
      669,
      670,
      671,
      672,
      673,
      406,
      407,
      408,
      409,
      410,
      411,
      412,
      413,
      414,
      599,
      600,
      601,
      602,
      713,
      714,
      715,
      716,
      689,
      690,
      691,
      692,
      693,
      19,
      20,
      21,
      22,
      583,
      584,
      585,
      698,
      699,
      700,
      701,
      702
    ],
    "name": "Dead-code",
    "exploit": "contract Contract{\n    function dead_code() internal() {}\n}\n",
    "description": "Functions that are not sued.",
    "recommendation": "Remove unused functions.",
    "explanation": "\n`dead_code` is not used in the contract, and make the code's review more difficult."
  },
  "Incorrect versions of Solidity": {
    "numberOfDuplicates": 1,
    "findType": "pragma",
    "title": "Pragma version0.8.19 (contracts/AuditContract.sol#12) necessitates a version too recent to be trusted. Consider deploying with 0.8.18.\n\nsolc-0.8.19 is not recommended for deployment\n",
    "check": "solc-version",
    "impact": "Informational",
    "confidence": "High",
    "sourceTest": "pragma solidity 0.8.19;\n",
    "lines": [
      12
    ],
    "name": "Incorrect versions of Solidity",
    "exploit": "",
    "description": "`solc` frequently releases new compiler versions. Using an old version prevents access to new Solidity security checks.\nWe also recommend avoiding complex `pragma` statement.",
    "recommendation": "Deploy with any of the following Solidity versions:\n- 0.8.18\n\nThe recommendations take into account:\n- Risks related to recent releases\n- Risks of complex code generation changes\n- Risks of new language features\n- Risks of known bugs\n\nUse a simple pragma version that allows any of these versions.\nConsider using the latest version of Solidity for testing."
  },
  "Low-level calls": {
    "numberOfDuplicates": 0,
    "findType": "function",
    "title": "Low level call in Prepe.swapBack() (contracts/AuditContract.sol#1284-1322):\n\t- (success,None) = address(devWallet).call{value: ethForDev}() (contracts/AuditContract.sol#1314)\n\t- (success,None) = address(marketingWallet).call{value: address(this).balance}() (contracts/AuditContract.sol#1321)\n",
    "check": "low-level-calls",
    "impact": "Informational",
    "confidence": "High",
    "sourceTest": "function swapBack() private {\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        uint256 totalTokensToSwap = tokensForLiquidity + tokensForMarketing + tokensForDev;\r\n        bool success;\r\n \r\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\r\n \r\n        if(contractBalance > swapTokensAtAmount * 20){\r\n          contractBalance = swapTokensAtAmount * 20;\r\n        }\r\n \r\n        // Halve the amount of liquidity tokens\r\n        uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;\r\n        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\r\n \r\n        uint256 initialETHBalance = address(this).balance;\r\n \r\n        swapTokensForEth(amountToSwapForETH); \r\n \r\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\r\n \r\n        uint256 ethForMarketing = ethBalance.mul(tokensForMarketing).div(totalTokensToSwap);\r\n        uint256 ethForDev = ethBalance.mul(tokensForDev).div(totalTokensToSwap);\r\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForDev;\r\n \r\n \r\n        tokensForLiquidity = 0;\r\n        tokensForMarketing = 0;\r\n        tokensForDev = 0;\r\n \r\n        (success,) = address(devWallet).call{value: ethForDev}(\"\");\r\n \r\n        if(liquidityTokens > 0 && ethForLiquidity > 0){\r\n            addLiquidity(liquidityTokens, ethForLiquidity);\r\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, tokensForLiquidity);\r\n        }\r\n \r\n        (success,) = address(marketingWallet).call{value: address(this).balance}(\"\");\r\n    }",
    "lines": [
      1284,
      1285,
      1286,
      1287,
      1288,
      1289,
      1290,
      1291,
      1292,
      1293,
      1294,
      1295,
      1296,
      1297,
      1298,
      1299,
      1300,
      1301,
      1302,
      1303,
      1304,
      1305,
      1306,
      1307,
      1308,
      1309,
      1310,
      1311,
      1312,
      1313,
      1314,
      1315,
      1316,
      1317,
      1318,
      1319,
      1320,
      1321,
      1322
    ],
    "name": "Low-level calls",
    "exploit": "",
    "description": "The use of low-level calls is error-prone. Low-level calls do not check for [code existence](https://solidity.readthedocs.io/en/v0.4.25/control-structures.html#error-handling-assert-require-revert-and-exceptions) or call success.",
    "recommendation": "Avoid low-level calls. Check the call success. If the call is meant for a contract, check for code existence."
  },
  "Redundant Statements": {
    "numberOfDuplicates": 0,
    "findType": "node",
    "title": "Redundant expression \"this (contracts/AuditContract.sol#20)\" inContext (contracts/AuditContract.sol#14-23)\n",
    "check": "redundant-statements",
    "impact": "Informational",
    "confidence": "High",
    "sourceTest": "this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691",
    "lines": [
      20
    ],
    "name": "Redundant Statements",
    "exploit": "contract RedundantStatementsContract {\n\n    constructor() public {\n        uint; // Elementary Type Name\n        bool; // Elementary Type Name\n        RedundantStatementsContract; // Identifier\n    }\n\n    function test() public returns (uint) {\n        uint; // Elementary Type Name\n        assert; // Identifier\n        test; // Identifier\n        return 777;\n    }\n}\n",
    "description": "Detect the usage of redundant statements that have no effect.",
    "recommendation": "Remove redundant statements if they congest code but offer no value.",
    "explanation": "\nEach commented line references types/identifiers, but performs no action with them, so no code will be generated for such statements and they can be removed."
  },
  "Too many digits": {
    "numberOfDuplicates": 4,
    "findType": "function",
    "title": "Prepe.updateSwapTokensAtAmount(uint256) (contracts/AuditContract.sol#1024-1029) uses literals with too many digits:\n\t- require(bool,string)(newAmount >= totalSupply() * 1 / 100000,Swap amount cannot be lower than 0.001% total supply.) (contracts/AuditContract.sol#1025)\n\nPrepe.constructor() (contracts/AuditContract.sol#945-998) uses literals with too many digits:\n\t- maxTransactionAmount = 21034500000000000000000000000000000 (contracts/AuditContract.sol#965)\n\nPrepe.constructor() (contracts/AuditContract.sol#945-998) uses literals with too many digits:\n\t- swapTokensAtAmount = 4413800000000000000000000000000 (contracts/AuditContract.sol#967)\n\nPrepe.constructor() (contracts/AuditContract.sol#945-998) uses literals with too many digits:\n\t- totalSupply = 420690000000000000000000000000000 (contracts/AuditContract.sol#964)\n\nPrepe.constructor() (contracts/AuditContract.sol#945-998) uses literals with too many digits:\n\t- maxWallet = 2524140000000000000000000000000 (contracts/AuditContract.sol#966)\n",
    "check": "too-many-digits",
    "impact": "Informational",
    "confidence": "Medium",
    "sourceTest": "function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner returns (bool){\r\n        require(newAmount >= totalSupply() * 1 / 100000, \"Swap amount cannot be lower than 0.001% total supply.\");\r\n        require(newAmount <= totalSupply() * 5 / 1000, \"Swap amount cannot be higher than 0.5% total supply.\");\r\n        swapTokensAtAmount = newAmount;\r\n        return true;\r\n    }\nconstructor() ERC20(\"President PEPE\", \"PREPE\") {\r\n \r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n \r\n        excludeFromMaxTransaction(address(_uniswapV2Router), true);\r\n        uniswapV2Router = _uniswapV2Router;\r\n \r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n        excludeFromMaxTransaction(address(uniswapV2Pair), true);\r\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\r\n \r\n        uint256 _buyMarketingFee = 2;\r\n        uint256 _buyLiquidityFee = 1;\r\n        uint256 _buyDevFee = 2;\r\n \r\n        uint256 _sellMarketingFee = 2;\r\n        uint256 _sellLiquidityFee = 1;\r\n        uint256 _sellDevFee = 2;\r\n \r\n        uint256 totalSupply = 420690000000000000000000000000000;\r\n        maxTransactionAmount = 21034500000000000000000000000000000;\r\n        maxWallet = 2524140000000000000000000000000;\r\n        swapTokensAtAmount = 4413800000000000000000000000000;\r\n\r\n        buyMarketingFee = _buyMarketingFee;\r\n        buyLiquidityFee = _buyLiquidityFee;\r\n        buyDevFee = _buyDevFee;\r\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\r\n \r\n        sellMarketingFee = _sellMarketingFee;\r\n        sellLiquidityFee = _sellLiquidityFee;\r\n        sellDevFee = _sellDevFee;\r\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\r\n \r\n        marketingWallet = address(0xcb7a1Ac1fDA24A1D26046aE3d0F3F80d966Fe000); // set as marketing wallet\r\n        devWallet = address(0xABac8df672bfE1822a9e99489148c1B25D155209); // set as dev wallet\r\n \r\n        // exclude from paying fees or having max transaction amount\r\n        excludeFromFees(owner(), true);\r\n        excludeFromFees(address(this), true);\r\n        excludeFromFees(address(0xdead), true);\r\n \r\n        excludeFromMaxTransaction(owner(), true);\r\n        excludeFromMaxTransaction(address(this), true);\r\n        excludeFromMaxTransaction(address(0xdead), true);\r\n        contractCreationTime = block.timestamp;\r\n        _sellFeesReset = false;\r\n \r\n        /*\r\n            _mint is an internal function in ERC20.sol that is only called here,\r\n            and CANNOT be called ever again\r\n        */\r\n        _mint(msg.sender, totalSupply);\r\n    }\nconstructor() ERC20(\"President PEPE\", \"PREPE\") {\r\n \r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n \r\n        excludeFromMaxTransaction(address(_uniswapV2Router), true);\r\n        uniswapV2Router = _uniswapV2Router;\r\n \r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n        excludeFromMaxTransaction(address(uniswapV2Pair), true);\r\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\r\n \r\n        uint256 _buyMarketingFee = 2;\r\n        uint256 _buyLiquidityFee = 1;\r\n        uint256 _buyDevFee = 2;\r\n \r\n        uint256 _sellMarketingFee = 2;\r\n        uint256 _sellLiquidityFee = 1;\r\n        uint256 _sellDevFee = 2;\r\n \r\n        uint256 totalSupply = 420690000000000000000000000000000;\r\n        maxTransactionAmount = 21034500000000000000000000000000000;\r\n        maxWallet = 2524140000000000000000000000000;\r\n        swapTokensAtAmount = 4413800000000000000000000000000;\r\n\r\n        buyMarketingFee = _buyMarketingFee;\r\n        buyLiquidityFee = _buyLiquidityFee;\r\n        buyDevFee = _buyDevFee;\r\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\r\n \r\n        sellMarketingFee = _sellMarketingFee;\r\n        sellLiquidityFee = _sellLiquidityFee;\r\n        sellDevFee = _sellDevFee;\r\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\r\n \r\n        marketingWallet = address(0xcb7a1Ac1fDA24A1D26046aE3d0F3F80d966Fe000); // set as marketing wallet\r\n        devWallet = address(0xABac8df672bfE1822a9e99489148c1B25D155209); // set as dev wallet\r\n \r\n        // exclude from paying fees or having max transaction amount\r\n        excludeFromFees(owner(), true);\r\n        excludeFromFees(address(this), true);\r\n        excludeFromFees(address(0xdead), true);\r\n \r\n        excludeFromMaxTransaction(owner(), true);\r\n        excludeFromMaxTransaction(address(this), true);\r\n        excludeFromMaxTransaction(address(0xdead), true);\r\n        contractCreationTime = block.timestamp;\r\n        _sellFeesReset = false;\r\n \r\n        /*\r\n            _mint is an internal function in ERC20.sol that is only called here,\r\n            and CANNOT be called ever again\r\n        */\r\n        _mint(msg.sender, totalSupply);\r\n    }\nconstructor() ERC20(\"President PEPE\", \"PREPE\") {\r\n \r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n \r\n        excludeFromMaxTransaction(address(_uniswapV2Router), true);\r\n        uniswapV2Router = _uniswapV2Router;\r\n \r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n        excludeFromMaxTransaction(address(uniswapV2Pair), true);\r\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\r\n \r\n        uint256 _buyMarketingFee = 2;\r\n        uint256 _buyLiquidityFee = 1;\r\n        uint256 _buyDevFee = 2;\r\n \r\n        uint256 _sellMarketingFee = 2;\r\n        uint256 _sellLiquidityFee = 1;\r\n        uint256 _sellDevFee = 2;\r\n \r\n        uint256 totalSupply = 420690000000000000000000000000000;\r\n        maxTransactionAmount = 21034500000000000000000000000000000;\r\n        maxWallet = 2524140000000000000000000000000;\r\n        swapTokensAtAmount = 4413800000000000000000000000000;\r\n\r\n        buyMarketingFee = _buyMarketingFee;\r\n        buyLiquidityFee = _buyLiquidityFee;\r\n        buyDevFee = _buyDevFee;\r\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\r\n \r\n        sellMarketingFee = _sellMarketingFee;\r\n        sellLiquidityFee = _sellLiquidityFee;\r\n        sellDevFee = _sellDevFee;\r\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\r\n \r\n        marketingWallet = address(0xcb7a1Ac1fDA24A1D26046aE3d0F3F80d966Fe000); // set as marketing wallet\r\n        devWallet = address(0xABac8df672bfE1822a9e99489148c1B25D155209); // set as dev wallet\r\n \r\n        // exclude from paying fees or having max transaction amount\r\n        excludeFromFees(owner(), true);\r\n        excludeFromFees(address(this), true);\r\n        excludeFromFees(address(0xdead), true);\r\n \r\n        excludeFromMaxTransaction(owner(), true);\r\n        excludeFromMaxTransaction(address(this), true);\r\n        excludeFromMaxTransaction(address(0xdead), true);\r\n        contractCreationTime = block.timestamp;\r\n        _sellFeesReset = false;\r\n \r\n        /*\r\n            _mint is an internal function in ERC20.sol that is only called here,\r\n            and CANNOT be called ever again\r\n        */\r\n        _mint(msg.sender, totalSupply);\r\n    }\nconstructor() ERC20(\"President PEPE\", \"PREPE\") {\r\n \r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n \r\n        excludeFromMaxTransaction(address(_uniswapV2Router), true);\r\n        uniswapV2Router = _uniswapV2Router;\r\n \r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n        excludeFromMaxTransaction(address(uniswapV2Pair), true);\r\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\r\n \r\n        uint256 _buyMarketingFee = 2;\r\n        uint256 _buyLiquidityFee = 1;\r\n        uint256 _buyDevFee = 2;\r\n \r\n        uint256 _sellMarketingFee = 2;\r\n        uint256 _sellLiquidityFee = 1;\r\n        uint256 _sellDevFee = 2;\r\n \r\n        uint256 totalSupply = 420690000000000000000000000000000;\r\n        maxTransactionAmount = 21034500000000000000000000000000000;\r\n        maxWallet = 2524140000000000000000000000000;\r\n        swapTokensAtAmount = 4413800000000000000000000000000;\r\n\r\n        buyMarketingFee = _buyMarketingFee;\r\n        buyLiquidityFee = _buyLiquidityFee;\r\n        buyDevFee = _buyDevFee;\r\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\r\n \r\n        sellMarketingFee = _sellMarketingFee;\r\n        sellLiquidityFee = _sellLiquidityFee;\r\n        sellDevFee = _sellDevFee;\r\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\r\n \r\n        marketingWallet = address(0xcb7a1Ac1fDA24A1D26046aE3d0F3F80d966Fe000); // set as marketing wallet\r\n        devWallet = address(0xABac8df672bfE1822a9e99489148c1B25D155209); // set as dev wallet\r\n \r\n        // exclude from paying fees or having max transaction amount\r\n        excludeFromFees(owner(), true);\r\n        excludeFromFees(address(this), true);\r\n        excludeFromFees(address(0xdead), true);\r\n \r\n        excludeFromMaxTransaction(owner(), true);\r\n        excludeFromMaxTransaction(address(this), true);\r\n        excludeFromMaxTransaction(address(0xdead), true);\r\n        contractCreationTime = block.timestamp;\r\n        _sellFeesReset = false;\r\n \r\n        /*\r\n            _mint is an internal function in ERC20.sol that is only called here,\r\n            and CANNOT be called ever again\r\n        */\r\n        _mint(msg.sender, totalSupply);\r\n    }",
    "lines": [
      1024,
      1025,
      1026,
      1027,
      1028,
      1029,
      945,
      946,
      947,
      948,
      949,
      950,
      951,
      952,
      953,
      954,
      955,
      956,
      957,
      958,
      959,
      960,
      961,
      962,
      963,
      964,
      965,
      966,
      967,
      968,
      969,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      978,
      979,
      980,
      981,
      982,
      983,
      984,
      985,
      986,
      987,
      988,
      989,
      990,
      991,
      992,
      993,
      994,
      995,
      996,
      997,
      998,
      945,
      946,
      947,
      948,
      949,
      950,
      951,
      952,
      953,
      954,
      955,
      956,
      957,
      958,
      959,
      960,
      961,
      962,
      963,
      964,
      965,
      966,
      967,
      968,
      969,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      978,
      979,
      980,
      981,
      982,
      983,
      984,
      985,
      986,
      987,
      988,
      989,
      990,
      991,
      992,
      993,
      994,
      995,
      996,
      997,
      998,
      945,
      946,
      947,
      948,
      949,
      950,
      951,
      952,
      953,
      954,
      955,
      956,
      957,
      958,
      959,
      960,
      961,
      962,
      963,
      964,
      965,
      966,
      967,
      968,
      969,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      978,
      979,
      980,
      981,
      982,
      983,
      984,
      985,
      986,
      987,
      988,
      989,
      990,
      991,
      992,
      993,
      994,
      995,
      996,
      997,
      998,
      945,
      946,
      947,
      948,
      949,
      950,
      951,
      952,
      953,
      954,
      955,
      956,
      957,
      958,
      959,
      960,
      961,
      962,
      963,
      964,
      965,
      966,
      967,
      968,
      969,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      978,
      979,
      980,
      981,
      982,
      983,
      984,
      985,
      986,
      987,
      988,
      989,
      990,
      991,
      992,
      993,
      994,
      995,
      996,
      997,
      998
    ],
    "name": "Too many digits",
    "exploit": "contract MyContract{\n    uint 1_ether = 10000000000000000000; \n}\n",
    "description": "Literals with many digits are difficult to read and review.",
    "recommendation": "Use:\n- [Ether suffix](https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#ether-units),\n- [Time suffix](https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#time-units), or\n- [The scientific notation](https://solidity.readthedocs.io/en/latest/types.html#rational-and-integer-literals)",
    "explanation": "\n\nWhile `1_ether` looks like `1 ether`, it is `10 ether`. As a result, it's likely to be used incorrectly."
  },
  "State variables that could be declared immutable": {
    "numberOfDuplicates": 0,
    "findType": "variable",
    "title": "Prepe.contractCreationTime (contracts/AuditContract.sol#908) should be immutable \n",
    "check": "immutable-states",
    "impact": "Optimization",
    "confidence": "High",
    "sourceTest": "uint256 public contractCreationTime;",
    "lines": [
      908
    ],
    "name": "State variables that could be declared immutable",
    "exploit": "",
    "description": "State variables that are not updated following deployment should be declared immutable to save gas.",
    "recommendation": "Add the `immutable` attribute to state variables that never change or are set only in the constructor."
  }
}